<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elevo Core Assistant</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%2317a2b8' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M3 12h18M3 6h12M3 18h15'/><path d='M17 9l4 3l-4 3'/></svg>">

    <link rel="stylesheet" href="style.css"> <!-- Ensure style.css path is correct -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- Add Animate.css (Optional, for more animations - replace simple fade below if used) -->
    <!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/> -->
</head>
<body>
    <!-- Audio Element for Sound Effect -->
    <!-- ÿ™ÿ£ŸÉÿØ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ŸÖÿ¨ŸÑÿØ 'sounds' Ÿàÿ®ÿØÿßÿÆŸÑŸá ŸÖŸÑŸÅ 'call_start.mp3' ŸÅŸä ŸÜŸÅÿ≥ ŸÖÿ≥ÿ™ŸàŸâ Ÿáÿ∞ÿß ÿßŸÑŸÖŸÑŸÅ ÿπŸÑŸâ GitHub Pages -->
    <audio id="callStartSound" src="sounds/call_start.mp3" preload="auto"></audio>

    <div class="app-container">
        <header class="app-header">
            <div class="logo-container">
                <svg class="company-logo" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M6 17L10 17M6 12L12 12M6 7L14 7" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                    <path d="M15 6L19 10L15 14" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <rect x="3" y="3" width="18" height="18" rx="3" stroke="currentColor" stroke-width="1.5" fill="transparent" opacity="0.6"/>
                </svg>
                <span class="app-title">Elevo Core</span>
            </div>
            <div class="header-controls">
                 <!-- Link to Dashboard -->
                 <a href="dashboard.html" class="nav-link">Dashboard</a>
                <div class="user-info" id="userInfo" style="display: none;">
                    <span id="userName" class="user-name-display"></span>
                    <button id="logoutButton" class="logout-btn">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line></svg>
                        <span>Logout</span>
                    </button>
                </div>
            </div>
        </header>

        <div class="status-bar">
            <div id="systemStatus" class="status-indicator status-waiting">üî¥ Waiting for Call</div>
            <!-- Timer moved out of status bar -->
        </div>

        <!-- Enhanced Progress Tracker -->
        <div id="progressTracker" class="progress-tracker-container" style="display: none;">
             <div class="stepper-wrapper">
                 <!-- Stepper will be dynamically generated here by JavaScript -->
            </div>
        </div>

        <!-- Centered Timer Container (NEW) -->
         <div id="timer-container">
             <div id="callTimer" style="display: none;">00:00</div>
         </div>

        <main class="app-main">
            <div id="auth-loading" class="loading-container">
                <div class="spinner"></div>
                <p>Initializing Assistant...</p>
            </div>

            <!-- Initial View with Scenario Selection -->
            <div id="initial-view" class="card initial-card fade-in" style="display: none;">
                <div class="card-icon">
                     <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="48" height="48"><path d="M12 2C6.486 2 2 6.486 2 12C2 17.514 6.486 22 12 22C17.514 22 22 17.514 22 12C22 6.486 17.514 2 12 2ZM12 20C7.589 20 4 16.411 4 12C4 7.589 7.589 4 12 4C16.411 4 20 7.589 20 12C20 16.411 16.411 20 12 20Z"/><path d="M12 11C10.897 11 10 10.103 10 9C10 7.897 10.897 7 12 7C13.103 7 14 7.897 14 9C14 10.103 13.103 11 12 11ZM12 9C11.514 9 11.121 9.229 11.038 9.583L12.962 10.417C12.879 10.771 12.486 11 12 11C11.448 11 11 10.552 11 10C11 9.448 11.448 9 12 9Z"/><path d="M16.002 16.246C15.483 15.219 14.544 14.5 13.333 14.5H10.667C9.456 14.5 8.517 15.219 7.998 16.246C7.933 16.386 7.996 16.553 8.114 16.641C8.657 17.053 9.737 17.5 12 17.5C14.263 17.5 15.343 17.053 15.886 16.641C16.004 16.553 16.067 16.386 16.002 16.246Z"/></svg>
                </div>
                <h2 class="card-title">Core Flow Assistant</h2>
                <p class="card-subtitle">Select a scenario and receive the call.</p>

                <!-- Scenario Selection Dropdown -->
                <div class="scenario-selector-container">
                    <label for="scenarioDropdown">Select Scenario:</label>
                    <select id="scenarioDropdown" class="scenario-dropdown">
                        <option value="">Loading scenarios...</option>
                    </select>
                </div>

                 <!-- Assistant Box (Initial Position - Moved here) -->
                <div id="assistantBox" class="assistant-box" style="display: none;"> <!-- Removed slide-in-right initially -->
                    <span class="assistant-icon">üí°</span>
                    <p id="assistantMessageElement">Welcome to Elevo Core!</p>
                </div>

                <button id="receive-call-btn" class="action-button primary-button" disabled> <!-- Disabled initially -->
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M6.05828 11.0452L4.00001 9.00002C4.00001 9.00002 3.58101 8.99902 3.51201 9.00002C2.04801 9.02602 1.00001 10.318 1.00001 11.785V12.214C1.00001 13.682 2.04801 14.973 3.51201 15H4.00001L6.05828 12.9548C6.12828 12.8848 6.16728 12.7948 6.16728 12C6.16728 11.2052 6.12828 11.1152 6.05828 11.0452ZM20.488 15H21C22.464 14.974 23.512 13.682 23.512 12.215V11.785C23.512 10.318 22.464 9.02602 21 9.00002C20.998 8.99902 20 9.00002 20 9.00002L17.9417 11.0452C17.8717 11.1152 17.8327 11.2052 17.8327 12C17.8327 12.7948 17.8717 12.8848 17.9417 12.9548L20.488 15Z"/><path d="M19.6623 5.08431C19.8803 5.08431 20.0943 5.17031 20.2503 5.32631L21.6743 6.74931C21.9863 7.06231 21.9863 7.56731 21.6743 7.87931C19.4003 10.1523 19.4003 13.8473 21.6743 16.1203C21.9863 16.4323 21.9863 16.9373 21.6743 17.2503L20.2503 18.6733C20.0943 18.8293 19.8803 18.9153 19.6623 18.9153C19.4443 18.9153 19.2303 18.8293 19.0743 18.6733C16.2573 15.8563 16.2573 8.14331 19.0743 5.32631C19.2303 5.17031 19.4443 5.08431 19.6623 5.08431ZM4.92575 5.32631C5.52575 4.72631 6.45075 4.72631 7.05075 5.32631C9.86775 8.14331 9.86775 15.8563 7.05075 18.6733C6.89475 18.8293 6.68075 18.9153 6.46275 18.9153C6.24475 18.9153 6.03075 18.8293 5.87475 18.6733L4.45075 17.2503C4.13875 16.9373 4.13875 16.4323 4.45075 16.1203C6.72375 13.8473 6.72375 10.1523 4.45075 7.87931C4.13875 7.56731 4.13875 7.06231 4.45075 6.74931L5.87475 5.32631C5.71875 5.17031 4.76975 5.17031 4.92575 5.32631Z"/></svg>
                    <span>Receive Call</span>
                </button>
            </div>

            <!-- Call Flow View -->
            <div id="call-flow-view" class="card call-flow-card fade-in" style="display: none;">
                <h3 id="scenario-title" class="card-title scenario-title-dynamic">Call Scenario</h3>
                <div id="steps-container" class="steps-area">
                    <p class="placeholder-text">Loading call steps...</p>
                </div>
                <div class="navigation-buttons">
                    <button id="prev-step-btn" class="nav-button secondary-button" style="display: none;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>
                        <span>Previous</span>
                    </button>
                    <button id="next-step-btn" class="nav-button primary-button">
                        <span>Next Step</span>
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>
                    </button>
                </div>
                 <button id="end-call-btn" class="nav-button danger-button" style="display: none;">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                    <span>End Call</span>
                </button>
            </div>

             <!-- Post Call Summary View -->
            <div id="postCallSummary" class="card post-call-summary-card fade-in" style="display: none;">
                <h3 class="card-title">Call Summary</h3>
                <div id="callSummaryContent">
                    <!-- Content will be injected by JS -->
                </div>
                <button id="returnToInitialViewBtn" class="action-button primary-button" style="margin-top: 1.5rem;">New Call</button>
            </div>

             <!-- Assistant Box (Fixed Position for Call - HTML remains outside card) -->
             <!-- JS will toggle classes for positioning -->
             <!-- <div id="assistantBox" ...> moved inside initial-view card for initial state -->

        </main>

        <footer class="app-footer">
            <p>¬© 2025 Mohamed Elmenisy - Elevo Core. All rights reserved.</p>
        </footer>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', async () => {
        console.log("CoreFlow.js DOMContentLoaded - v2.3 (State Persistence, Timer/Assistant Pos)"); // Version updated

        // --- Supabase Client Initialization ---
        const supabaseUrl = 'https://lgcutmuspcaralydycmg.supabase.co';
        const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxnY3V0bXVzcGNhcmFseWR5Y21nIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU0NDY3MDEsImV4cCI6MjA2MTAyMjcwMX0.3u5Y7pkH2NNnnoGLMWVfAa5b8fq88o1itRYnG1K38tE';
        let supabase;
        try {
            supabase = window.supabase.createClient(supabaseUrl, supabaseAnonKey);
            console.log("Supabase client initialized in coreFlow.js v2.3");
        } catch (error) {
            console.error("Supabase client initialization failed:", error);
            document.getElementById('auth-loading').innerHTML = '<p style="color:red;">Error: Could not connect to services.</p>';
            return;
        }

        // --- DOM Elements ---
        const authLoadingDiv = document.getElementById('auth-loading');
        const initialViewDiv = document.getElementById('initial-view');
        const callFlowViewDiv = document.getElementById('call-flow-view');
        const scenarioDropdown = document.getElementById('scenarioDropdown');
        const receiveCallBtn = document.getElementById('receive-call-btn');
        const stepsContainer = document.getElementById('steps-container');
        const nextStepBtn = document.getElementById('next-step-btn');
        const prevStepBtn = document.getElementById('prev-step-btn');
        const endCallBtn = document.getElementById('end-call-btn');
        const scenarioTitleElement = document.getElementById('scenario-title');
        const userInfoDiv = document.getElementById('userInfo');
        const userNameSpan = document.getElementById('userName');
        const logoutButton = document.getElementById('logoutButton');
        const systemStatusDiv = document.getElementById('systemStatus');
        const callTimerDiv = document.getElementById('callTimer'); // Reference to the moved timer
        const progressTrackerContainer = document.getElementById('progressTracker');
        const assistantBox = document.getElementById('assistantBox');
        const assistantMessageElement = document.getElementById('assistantMessageElement');
        const postCallSummaryDiv = document.getElementById('postCallSummary');
        const callSummaryContentDiv = document.getElementById('callSummaryContent');
        const returnToInitialViewBtn = document.getElementById('returnToInitialViewBtn');
        const callStartSound = document.getElementById('callStartSound');

        // --- State Variables ---
        let currentScenarioId = null;
        let currentScenarioName = null;
        let currentSteps = [];
        let currentStepIndex = 0;
        let stepTimerInterval = null;
        let stepStartTime = 0;
        let totalElapsedSecondsOnLoad = 0; // For restoring timer
        let stepDurations = []; // Stores accumulated seconds per step index
        let currentCallSessionId = null;
        let assistantTimeout = null;
        let typingInterval = null;
        let availableScenarios = [];
        const SESSION_STATE_KEY = 'elevoCoreActiveCallState'; // Key for SessionStorage

        // --- Animation Helper ---
        function animateElement(element, animationClass = 'fade-in') {
             if (element) {
                element.classList.remove(animationClass);
                void element.offsetWidth;
                element.classList.add(animationClass);
            }
        }

         // --- Session State Persistence ---
         function saveCallState() {
            if (!currentCallSessionId) return; // Don't save if no active call

            const state = {
                sessionId: currentCallSessionId,
                scenarioId: currentScenarioId,
                scenarioName: currentScenarioName,
                steps: currentSteps,
                stepIndex: currentStepIndex,
                durations: stepDurations,
                startTime: stepStartTime, // Save the *start* time of the current step
                timestamp: Date.now() // To potentially check freshness later if needed
            };
            try {
                sessionStorage.setItem(SESSION_STATE_KEY, JSON.stringify(state));
                console.log("Call state saved:", state);
            } catch (e) {
                console.error("Error saving call state to SessionStorage:", e);
            }
        }

        function loadCallState() {
            try {
                const savedState = sessionStorage.getItem(SESSION_STATE_KEY);
                if (savedState) {
                    const state = JSON.parse(savedState);
                    console.log("Found saved call state:", state);
                    // Optional: Add check for state freshness using state.timestamp if needed

                    // Restore state variables
                    currentCallSessionId = state.sessionId;
                    currentScenarioId = state.scenarioId;
                    currentScenarioName = state.scenarioName;
                    currentSteps = state.steps || [];
                    currentStepIndex = state.stepIndex !== undefined ? state.stepIndex : 0;
                    stepDurations = state.durations || new Array(currentSteps.length).fill(0);
                    stepStartTime = state.startTime || 0; // Restore start time

                    // Calculate how much time already passed in the current step when page loaded
                    if (stepStartTime > 0) {
                         totalElapsedSecondsOnLoad = Math.floor((Date.now() - stepStartTime) / 1000);
                         console.log(`Restored step started at ${new Date(stepStartTime)}, ${totalElapsedSecondsOnLoad}s already elapsed.`);
                    } else {
                         totalElapsedSecondsOnLoad = 0;
                    }

                    return true; // Indicate state was loaded
                }
            } catch (e) {
                console.error("Error loading call state from SessionStorage:", e);
                clearCallState(); // Clear potentially corrupted state
            }
            return false; // Indicate no state loaded
        }

        function clearCallState() {
            sessionStorage.removeItem(SESSION_STATE_KEY);
            console.log("Call state cleared from SessionStorage.");
        }

         // --- 1. CHECK AUTHENTICATION & USER INFO (Handles state restore) ---
        try {
             const { data: { session }, error: sessionError } = await supabase.auth.getSession();
             if (sessionError) throw sessionError;
             if (!session) {
                 const currentPath = window.location.pathname.replace('/elevo-core-flow', '') + window.location.search + window.location.hash;
                 window.location.href = `../legacy/login.html?redirectTo=${encodeURIComponent(currentPath || '/core-flow/core-flow.html')}`;
                 return;
             }

             console.log('User is authenticated.');
             if (session.user.email && userNameSpan && userInfoDiv) {
                 const emailPrefix = session.user.email.split('@')[0];
                 userNameSpan.textContent = emailPrefix.charAt(0).toUpperCase() + emailPrefix.slice(1);
                 userInfoDiv.style.display = 'flex';
             }
             if(logoutButton) {
                 logoutButton.addEventListener('click', async () => {
                     clearCallState(); // Clear state on logout
                     const { error } = await supabase.auth.signOut();
                     if (error) console.error("Logout error:", error);
                     else window.location.href = '../legacy/login.html';
                 });
             }

             // --- Attempt to Load Saved Call State ---
             const stateLoaded = loadCallState();

             if (authLoadingDiv) authLoadingDiv.style.display = 'none';

             if (stateLoaded && currentCallSessionId && currentSteps.length > 0) {
                 console.log("Restoring active call session...");
                 // Show call flow view directly
                 if (initialViewDiv) initialViewDiv.style.display = 'none';
                 if (callFlowViewDiv) {
                     callFlowViewDiv.style.display = 'block';
                     // No animation needed on restore? Or maybe a subtle one? Let's skip for now.
                     // animateElement(callFlowViewDiv);
                 }
                 if (scenarioTitleElement) scenarioTitleElement.textContent = currentScenarioName || 'Restored Scenario';
                 updateSystemStatus("üü¢ In Call (Restored)", "status-in-call");
                 if (endCallBtn) endCallBtn.style.display = 'inline-flex';

                 renderProgressTracker(); // Render tracker based on restored index
                 renderStep(); // Render current step (this will also restart the timer correctly)

                 // No need to load scenarios again if restoring
             } else {
                 console.log("No active call state found or state invalid. Loading initial view.");
                 // Proceed with normal initial view loading
                 clearCallState(); // Ensure any invalid state is cleared
                 await loadActiveScenarios();

                 if (initialViewDiv) {
                     initialViewDiv.style.display = 'block';
                     animateElement(initialViewDiv);
                 }
                 updateSystemStatus("üî¥ Waiting for Call");
                  showAssistantMessage("Welcome! Select a scenario to begin.", true, 'initial', 6000, () => {
                     if (initialViewDiv && initialViewDiv.style.display === 'block') {
                          showAssistantMessage("üí° Tip: Choose a scenario and click 'Receive Call'.", true, 'initial', 0);
                     }
                 });
             }

        } catch (error) {
            console.error("Auth or Initial Load/Restore error:", error);
            if (authLoadingDiv) authLoadingDiv.innerHTML = `<p style="color:red;">Error: ${error.message}</p>`;
            updateSystemStatus("üî¥ Error", "status-error");
            clearCallState(); // Clear state on error
        }

        // --- 2. LOAD ACTIVE SCENARIOS ---
        async function loadActiveScenarios() {
            if (!scenarioDropdown || !receiveCallBtn) return;
            scenarioDropdown.disabled = true;
            receiveCallBtn.disabled = true;
            scenarioDropdown.innerHTML = '<option value="">Loading scenarios...</option>';

            try {
                const { data: scenarios, error } = await supabase
                    .from('call_scenarios')
                    .select('id, name')
                    .eq('is_active', true)
                    .order('name', { ascending: true });

                if (error) throw error;

                availableScenarios = scenarios || [];

                if (availableScenarios.length > 0) {
                    scenarioDropdown.innerHTML = '<option value="">-- Select a Scenario --</option>';
                    availableScenarios.forEach(scenario => {
                        const option = document.createElement('option');
                        option.value = scenario.id;
                        option.textContent = scenario.name;
                        scenarioDropdown.appendChild(option);
                    });
                    scenarioDropdown.disabled = false;
                    scenarioDropdown.addEventListener('change', () => {
                         receiveCallBtn.disabled = !scenarioDropdown.value;
                    });
                } else {
                    scenarioDropdown.innerHTML = '<option value="">No active scenarios found</option>';
                    showAssistantMessage("‚ö†Ô∏è No active call scenarios available.", true, 'initial', 0);
                }
            } catch (err) {
                console.error("Error loading scenarios:", err);
                scenarioDropdown.innerHTML = '<option value="">Error loading scenarios</option>';
                showAssistantMessage(`‚ö†Ô∏è Error loading scenarios: ${err.message}`, true, 'initial', 8000);
            }
        }

        // --- UTILITY FUNCTIONS (updateSystemStatus, Timers, Reset, etc.) ---
        function updateSystemStatus(statusText, statusClass = 'status-waiting') {
            if (systemStatusDiv) {
                systemStatusDiv.textContent = statusText;
                systemStatusDiv.className = `status-indicator ${statusClass}`;
            }
        }

        function startStepTimer() {
            if (callTimerDiv) callTimerDiv.style.display = 'inline-block'; // Changed from block
            if (stepTimerInterval) clearInterval(stepTimerInterval);

            let accumulatedSeconds = 0;
            if (stepStartTime > 0) { // Check if restoring or returning to step
                 accumulatedSeconds = totalElapsedSecondsOnLoad > 0 ? totalElapsedSecondsOnLoad : Math.floor((Date.now() - stepStartTime) / 1000);
                 console.log(`Restarting timer. Start time: ${stepStartTime}, Accumulated: ${accumulatedSeconds}s`);
                 totalElapsedSecondsOnLoad = 0; // Reset accumulator for load
             } else { // Starting step fresh
                 stepStartTime = Date.now();
                 accumulatedSeconds = 0;
                 console.log(`Starting timer fresh. Start time: ${stepStartTime}`);
            }
            // Save state immediately when timer starts/restarts
            saveCallState();

            const updateDisplay = () => {
                const currentElapsedTime = Math.floor((Date.now() - stepStartTime) / 1000);
                const totalSecondsForStep = currentElapsedTime; // Keep track of current step time
                const minutes = String(Math.floor(totalSecondsForStep / 60)).padStart(2, '0');
                const seconds = String(totalSecondsForStep % 60).padStart(2, '0');
                if (callTimerDiv) callTimerDiv.textContent = `${minutes}:${seconds}`;
            };

            updateDisplay(); // Initial display

            stepTimerInterval = setInterval(updateDisplay, 1000);
        }

        function stopAndRecordStepTimer() {
            clearInterval(stepTimerInterval);
            stepTimerInterval = null;
            if (stepStartTime > 0 && currentStepIndex >= 0 && currentStepIndex < currentSteps.length) {
                const duration = Math.floor((Date.now() - stepStartTime) / 1000);
                 if (!stepDurations) stepDurations = new Array(currentSteps.length).fill(0); // Initialize if needed

                 if (currentStepIndex < stepDurations.length) {
                     // Only add the *new* duration since the last start/resume
                    stepDurations[currentStepIndex] = (stepDurations[currentStepIndex] || 0) + duration;
                    console.log(`Step ${currentStepIndex + 1} duration recorded: ${duration}s. Accumulated: ${stepDurations[currentStepIndex]}s`);
                 } else {
                    console.warn(`Attempted to record duration for invalid step index ${currentStepIndex}`);
                 }
                 stepStartTime = 0; // Reset start time for the *next* step
                 saveCallState(); // Save state after recording duration
            } else {
                 stepStartTime = 0; // Ensure start time is reset even if no duration recorded
            }
        }


        function resetCallSessionState() {
            stopAndRecordStepTimer(); // Stop timer first
            clearCallState(); // Clear from SessionStorage

            if (callTimerDiv) {
                callTimerDiv.textContent = '00:00';
                callTimerDiv.style.display = 'none';
            }
            stepDurations = [];
            currentCallSessionId = null;
            currentScenarioId = null;
            currentScenarioName = null;
            currentSteps = [];
            currentStepIndex = 0;
            stepStartTime = 0; // Reset start time
            totalElapsedSecondsOnLoad = 0;
            console.log("Call session state reset completely.");
        }

        // --- 3. RENDER STEP & PROGRESS TRACKER ---
         function renderProgressTracker() {
            if (!progressTrackerContainer || currentSteps.length === 0) {
                if(progressTrackerContainer) progressTrackerContainer.style.display = 'none';
                return;
            }
             const stepperWrapper = progressTrackerContainer.querySelector('.stepper-wrapper');
             if (!stepperWrapper) {
                 console.error("Stepper wrapper not found!");
                 return;
             }
             stepperWrapper.innerHTML = '';

            const stepperUl = document.createElement('ul');
            stepperUl.className = 'stepper';

            currentSteps.forEach((step, index) => {
                const stepLi = document.createElement('li');
                stepLi.className = 'step';

                const stepNumber = document.createElement('span');
                stepNumber.className = 'step-number';
                stepNumber.textContent = index + 1;

                const stepTitle = document.createElement('span');
                stepTitle.className = 'step-title';
                stepTitle.textContent = `Action ${index + 1}`;

                stepLi.appendChild(stepNumber);
                // stepLi.appendChild(stepTitle); // Titles still hidden by default css

                if (index < currentStepIndex) {
                    stepLi.classList.add('completed');
                    stepNumber.innerHTML = '‚úì';
                } else if (index === currentStepIndex) {
                    stepLi.classList.add('active');
                }

                stepperUl.appendChild(stepLi);

                if (index < currentSteps.length - 1) {
                    const separator = document.createElement('li');
                    separator.className = 'step-separator';
                    stepperUl.appendChild(separator);
                }
            });

            stepperWrapper.appendChild(stepperUl);
            progressTrackerContainer.style.display = 'block';
             // Avoid redundant animation on simple re-render
             // animateElement(progressTrackerContainer);
        }

        function renderStep() {
            if (!stepsContainer) return;

            // Ensure stepStartTime is reset if moving to a step that hasn't been started yet
            // Check if we're moving to a step whose duration is 0 (or undefined) and start time isn't already set
            if ((!stepDurations[currentStepIndex] || stepDurations[currentStepIndex] === 0) && stepStartTime === 0 && totalElapsedSecondsOnLoad === 0) {
                stepStartTime = Date.now(); // Set start time only if truly starting fresh
                 console.log(`Setting new stepStartTime for step ${currentStepIndex + 1}: ${stepStartTime}`);
            } else if (totalElapsedSecondsOnLoad > 0) {
                 // If restoring from load, stepStartTime is already set by loadCallState
                 console.log(`Restoring step ${currentStepIndex + 1}, using existing stepStartTime: ${stepStartTime}`);
             } else if (stepStartTime === 0) {
                // Navigating back to a step that *was* started before
                stepStartTime = Date.now() - (stepDurations[currentStepIndex] * 1000 || 0); // Estimate original start based on recorded duration
                console.log(`Returning to step ${currentStepIndex + 1}. Estimated start time: ${stepStartTime}`);
             }

            if (currentSteps.length === 0) {
                stepsContainer.innerHTML = '<p class="placeholder-text">No steps defined for this scenario.</p>';
                if (nextStepBtn) nextStepBtn.style.display = 'none';
                if (prevStepBtn) prevStepBtn.style.display = 'none';
                return;
            }
            if (currentStepIndex >= 0 && currentStepIndex < currentSteps.length) {
                const stepContent = currentSteps[currentStepIndex];
                 // Subtle content update without harsh flash
                 stepsContainer.innerHTML = `<p>${stepContent}</p>`;
                 // stepsContainer.classList.remove('fade-in');
                 // void stepsContainer.offsetWidth;
                 // stepsContainer.classList.add('fade-in');

                showAssistantMessage(`üìå Step ${currentStepIndex + 1}: ${stepContent.length > 45 ? stepContent.substring(0, 42) + "..." : stepContent}`, true, 'call', 0);
                startStepTimer(); // This now handles restoring elapsed time too
                 saveCallState(); // Save state whenever a step is rendered
            } else {
                 console.error("Invalid currentStepIndex:", currentStepIndex);
                 stepsContainer.innerHTML = '<p class="placeholder-text" style="color: var(--danger-color);">Error: Invalid step.</p>';
            }

            renderProgressTracker();
            if (prevStepBtn) prevStepBtn.style.display = currentStepIndex > 0 ? 'inline-flex' : 'none';
            if (nextStepBtn) {
                if (currentStepIndex < currentSteps.length - 1) {
                    nextStepBtn.innerHTML = `<span>Next Step</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>`;
                    nextStepBtn.style.display = 'inline-flex';
                } else if (currentStepIndex === currentSteps.length - 1) {
                    nextStepBtn.innerHTML = `<span>Finish Scenario</span>`;
                    nextStepBtn.style.display = 'inline-flex';
                } else {
                    nextStepBtn.style.display = 'none';
                }
            }
        }

        // --- 4. "RECEIVE CALL" BUTTON FUNCTIONALITY ---
        if (receiveCallBtn) {
            receiveCallBtn.addEventListener('click', async () => {
                const selectedScenarioId = scenarioDropdown.value;
                if (!selectedScenarioId) {
                    showAssistantMessage("‚ö†Ô∏è Please select a scenario first.", true, 'initial', 5000);
                    return;
                }
                console.log(`Receive Call button clicked for scenario ID: ${selectedScenarioId}`);
                 if(callStartSound) {
                    callStartSound.play().catch(e => console.warn("Audio play failed:", e));
                 }

                resetCallSessionState(); // Reset state *before* starting new session
                currentScenarioId = parseInt(selectedScenarioId, 10);

                if (initialViewDiv) initialViewDiv.style.display = 'none';
                if (callFlowViewDiv) {
                    callFlowViewDiv.style.display = 'block';
                     animateElement(callFlowViewDiv);
                }
                if (endCallBtn) endCallBtn.style.display = 'inline-flex';
                updateSystemStatus("üü° Loading Scenario...", "status-loading");
                if (stepsContainer) stepsContainer.innerHTML = '<p class="placeholder-text">Loading scenario...</p>';
                if (scenarioTitleElement) scenarioTitleElement.textContent = 'Loading Scenario...';
                if (progressTrackerContainer) progressTrackerContainer.style.display = 'none';
                if (nextStepBtn) nextStepBtn.style.display = 'none';
                if (prevStepBtn) prevStepBtn.style.display = 'none';

                try {
                    const { data: { user } } = await supabase.auth.getUser();
                    if (!user) throw new Error("User not identified. Cannot start call.");

                    const { data: scenario, error: scenarioError } = await supabase
                        .from('call_scenarios')
                        .select('name, steps')
                        .eq('id', currentScenarioId)
                        .eq('is_active', true)
                        .single();

                    if (scenarioError) throw scenarioError;
                    if (!scenario || !scenario.steps || !Array.isArray(scenario.steps) || scenario.steps.length === 0) {
                         throw new Error("Selected scenario is invalid or has no steps.");
                    }

                    currentScenarioName = scenario.name;
                    currentSteps = scenario.steps;
                    currentStepIndex = 0;
                    stepDurations = new Array(currentSteps.length).fill(0); // Reset durations for new call
                    stepStartTime = 0; // Reset start time

                    // *** Create session and STORE the ID ***
                    const { data: newSession, error: sessionInsertError } = await supabase
                        .from('call_sessions')
                        .insert({
                            user_id: user.id,
                            scenario_id: currentScenarioId,
                            start_time: new Date().toISOString(),
                            completed_all_steps: false,
                            agent_name: user.name || '',       // ÿ™ÿ£ŸÉÿØ ÿ•ŸÜ `user.name` ŸÖŸàÿ¨ŸàÿØ
                            agent_email: user.email || '',     // ÿ™ÿ£ŸÉÿØ ÿ•ŸÜ `user.email` ŸÖŸàÿ¨ŸàÿØ
                            // Set initial quality/reason to pending or null in DB if desired
                            // call_quality: 'Pending',
                            // quality_reason: 'Evaluation pending'
                        })
                        .select('id') // IMPORTANT: Select the ID
                        .single();

                    if (sessionInsertError || !newSession) {
                        throw sessionInsertError || new Error("Failed to create session record.");
                    }

                    currentCallSessionId = newSession.id; // <-- STORE THE ID HERE
                    console.log("‚úÖ New call session created. ID:", currentCallSessionId);

                    if (scenarioTitleElement) scenarioTitleElement.textContent = currentScenarioName;
                    updateSystemStatus("üü¢ In Call", "status-in-call");
                    renderProgressTracker();
                    renderStep(); // This will start the timer and save initial state
                    showAssistantMessage(`üöÄ Scenario "${currentScenarioName}" started!`, true, 'call', 0);
                    // Initial state saved within renderStep -> startStepTimer -> saveCallState

                } catch (err) {
                    console.error("Error during call setup:", err);
                    resetCallSessionState(); // Ensure reset on error (clears session storage too)
                    if (callTimerDiv) callTimerDiv.style.display = 'none';
                    let userMessage = `‚ö†Ô∏è Error starting call: ${err.message}`;
                    if (err.code === 'PGRST116') userMessage = `‚ö†Ô∏è Error: Could not find details for selected scenario (ID: ${currentScenarioId}). It might have been deactivated.`;

                    if (stepsContainer) stepsContainer.innerHTML = `<p class="placeholder-text" style="color:red;">${userMessage.substring(3)}</p>`;
                    if (scenarioTitleElement) scenarioTitleElement.textContent = 'Error Loading';
                    updateSystemStatus("üî¥ Error", "status-error");
                     showAssistantMessage(userMessage, true, 'initial', 7000); // Show error in initial context

                    if (callFlowViewDiv) callFlowViewDiv.style.display = 'none';
                    if (initialViewDiv) {
                         initialViewDiv.style.display = 'block';
                         animateElement(initialViewDiv);
                    }
                    if (endCallBtn) endCallBtn.style.display = 'none';
                     await loadActiveScenarios(); // Reload scenarios on error
                }
            });
        }

        // --- 5. NAVIGATION BUTTONS (Next/Prev) ---
        if (nextStepBtn) {
            nextStepBtn.addEventListener('click', async () => {
                stopAndRecordStepTimer(); // Records duration, resets stepStartTime, saves state
                if (currentStepIndex < currentSteps.length - 1) {
                    currentStepIndex++;
                    stepStartTime = 0; // Explicitly reset for next step start
                    totalElapsedSecondsOnLoad = 0; // Not restoring
                    renderStep(); // Starts timer for new step, saves state
                } else if (currentStepIndex === currentSteps.length - 1) {
                    // --- Call FINISHED ---
                    console.log(`Scenario ${currentScenarioName} fully completed by user.`);
                    updateSystemStatus("‚úÖ Call Completed", "status-completed");
                    clearCallState(); // Clear state on successful completion

                    const totalDuration = stepDurations.reduce((acc, duration) => acc + (duration || 0), 0);
                    const completedAllSteps = true;

                    // --- START: MODIFICATION for Finish Call (Body Change) ---
                    let quality = 'Good'; // Example: Assign based on completion
                    let reason = 'All steps completed.'; // Example reason

                    if (!currentCallSessionId) {
                        console.error("‚ùå Cannot evaluate session, currentCallSessionId is missing!");
                        reason = "Internal Error: Missing Session ID for evaluation.";
                        quality = 'N/A'; // Set quality to N/A if ID is missing
                    } else {
                        console.log(`üöÄ Invoking evaluate-call-session (Finish) for session: ${currentCallSessionId}`);
                        console.log(`   Sending Body: { sessionId: ${currentCallSessionId}, quality: ${quality}, reason: "${reason}" }`);
                        try {
                            const { data, error: functionError } = await supabase.functions.invoke('evaluate-call-session', {
                                body: {
                                    sessionId: currentCallSessionId,
                                    quality: quality,
                                    reason: reason
                                }
                            });

                            if (functionError) throw functionError; // Let catch block handle non-2xx
                            console.log("‚úÖ Edge function invoked successfully (Finish). Response:", data);
                            if (data && data.updatedQuality) quality = data.updatedQuality;
                            if (data && data.updatedReason) reason = data.updatedReason;

                        } catch (err) {
                            console.error("‚ùå Error calling evaluate-call-session function (Finish):", err);
                            if (err.context?.response?.status && err.context?.response?.status !== 200) {
                                reason = `Evaluation failed: Edge Function returned status ${err.context.response.status}. ${err.message || ''}`;
                            } else {
                                reason = `Evaluation failed: ${err.message || 'Unknown error'}`;
                            }
                             quality = 'N/A'; // Set to N/A on error
                        }
                    }
                     // --- END: MODIFICATION for Finish Call ---

                    console.log(`Final Outcome (Finish) - Quality: ${quality}, Reason: ${reason}`);
                    displayPostCallSummary(quality, reason, totalDuration); // Display summary

                    // Hide call controls after summary is prepared
                    if (nextStepBtn) nextStepBtn.style.display = 'none';
                    if (prevStepBtn) prevStepBtn.style.display = 'none';
                    if (endCallBtn) endCallBtn.style.display = 'none';
                     // Ensure state is cleared (already done above)
                }
            });
        }

        if (prevStepBtn) {
            prevStepBtn.addEventListener('click', () => {
                stopAndRecordStepTimer(); // Record time of the step we are leaving, save state
                if (currentStepIndex > 0) {
                    currentStepIndex--;
                    // Timer restart logic is handled within renderStep
                    stepStartTime = 0; // Explicitly reset, renderStep will handle re-estimating based on duration
                    totalElapsedSecondsOnLoad = 0; // Not restoring
                    renderStep(); // Renders the previous step, timer will restart, state will be saved
                }
            });
        }

        // --- 6. END CALL BUTTON ---
        if (endCallBtn) {
            endCallBtn.addEventListener('click', async () => {
                stopAndRecordStepTimer(); // Record time for the current step before ending
                const totalDuration = stepDurations.reduce((acc, duration) => acc + (duration || 0), 0);
                console.log("üü° End Call button clicked by user.");
                updateSystemStatus("‚ö™ Call Ended", "status-ended");
                clearCallState(); // Clear state on manual end

                const completedAllSteps = false; // Explicitly false

                 // --- START: MODIFICATION for End Call (Body Change) ---
                 let quality = 'Bad'; // Example: Assign based on premature end
                 let reason = 'Call ended prematurely by user.'; // Example reason

                 if (!currentCallSessionId) {
                    console.error("‚ùå Cannot evaluate session, currentCallSessionId is missing!");
                    reason = "Internal Error: Missing Session ID for evaluation.";
                    quality = 'N/A';
                } else {
                     console.log(`üöÄ Invoking evaluate-call-session (End Call) for session: ${currentCallSessionId}`);
                     console.log(`   Sending Body: { sessionId: ${currentCallSessionId}, quality: ${quality}, reason: "${reason}" }`);
                    try {
                         const { data, error: functionError } = await supabase.functions.invoke('evaluate-call-session', {
                             body: {
                                sessionId: currentCallSessionId,
                                quality: quality,
                                reason: reason
                            }
                        });
                        if (functionError) throw functionError;

                        console.log("‚úÖ Edge function invoked successfully (End Call). Response:", data);
                         if (data && data.updatedQuality) quality = data.updatedQuality;
                         if (data && data.updatedReason) reason = data.updatedReason;

                    } catch (err) {
                        console.error("‚ùå Error calling evaluate-call-session function (End Call):", err);
                         if (err.context?.response?.status && err.context?.response?.status !== 200) {
                            reason = `Evaluation failed: Edge Function returned status ${err.context.response.status}. ${err.message || ''}. Call ended prematurely.`;
                         } else {
                             reason = `Evaluation failed: ${err.message || 'Unknown error'}. Call ended prematurely.`;
                         }
                         quality = 'N/A'; // Set to N/A on error
                    }
                }
                // --- END: MODIFICATION for End Call ---

                console.log(`Final Outcome (End Call) - Quality: ${quality}, Reason: ${reason}`);
                displayPostCallSummary(quality, reason, totalDuration);

                // Hide call controls
                if (nextStepBtn) nextStepBtn.style.display = 'none';
                if (prevStepBtn) prevStepBtn.style.display = 'none';
                if (endCallBtn) endCallBtn.style.display = 'none';
                // State already cleared
            });
        }

        // --- 7. POST CALL SUMMARY & RETURN ---
        function displayPostCallSummary(quality, reason, totalDuration) {
             clearCallState(); // Ensure state is cleared when showing summary

            if (callFlowViewDiv) callFlowViewDiv.style.display = 'none';
            if (progressTrackerContainer) progressTrackerContainer.style.display = 'none';
            if (callTimerDiv) callTimerDiv.style.display = 'none'; // Hide timer
            if (assistantBox) {
                 assistantBox.classList.remove('show', 'assistant-initial-position'); // Hide assistant
                 assistantBox.style.display = 'none';
            }


            if (callSummaryContentDiv && postCallSummaryDiv) {
                let summaryHTML = `
                    <p><strong>Call Quality:</strong> <span class="quality-text quality-${quality?.toLowerCase().replace(/\s+/g, '-') || 'na'}">${quality || 'N/A'}</span></p> <!-- Improved class handling -->
                    <p><strong>Reason:</strong> ${reason || "N/A"}</p>
                    <p><strong>Total Duration:</strong> ${Math.floor(totalDuration / 60)}m ${totalDuration % 60}s</p>
                    <hr style="margin: 1rem 0; border-color: var(--border-color);">
                    <p><strong>Step Durations (approx):</strong></p> <!-- Added 'approx' -->
                    <ul style="list-style: none; padding-left: 0; max-height: 150px; overflow-y: auto;">`;

                 if (currentSteps && currentSteps.length > 0 && stepDurations && stepDurations.length > 0) { // Adjusted check
                     const maxValidIndex = Math.min(currentSteps.length, stepDurations.length);
                     for (let index = 0; index < maxValidIndex; index++) {
                          const duration = stepDurations[index] || 0;
                          const stepText = currentSteps[index] || `Step ${index + 1}`;
                          const stepShortText = stepText.length > 25 ? stepText.substring(0, 22) + "..." : stepText;
                          const timeStr = `${Math.floor(duration / 60)}m ${duration % 60}s`;
                          // Determine status based on *final* outcome
                          const wasCompleted = (quality === 'Good' && index === maxValidIndex - 1) || index < currentStepIndex;
                          const status = duration > 0 ? (wasCompleted ? 'Completed' : 'Ended At') : 'Not Reached';

                          if(duration > 0 || (index === currentStepIndex && quality !=='Good' && quality !== 'N/A')) { // Show if duration exists OR it was the last active step in a non-good call
                            summaryHTML += `<li style="margin-bottom: 0.3rem;">${index + 1}. "${stepShortText}" (${status}): ${timeStr}</li>`;
                          } else if (index > currentStepIndex && stepDurations[index-1] > 0 && quality !== 'Good') {
                             // Optionally show next step as not reached if call ended early
                              summaryHTML += `<li style="margin-bottom: 0.3rem; opacity: 0.6;">${index + 1}. "${stepShortText}" (Not Reached)</li>`;
                          }
                     }
                 } else {
                     summaryHTML += `<li>No step duration data available.</li>`;
                 }
                summaryHTML += `</ul>`;

                callSummaryContentDiv.innerHTML = summaryHTML;
                postCallSummaryDiv.style.display = 'block';
                 animateElement(postCallSummaryDiv);
            }
            updateSystemStatus("üìä Review Call Summary", "status-summary");
        }

         // Function to reset the UI to the initial state
         async function resetToInitialView() {
             resetCallSessionState(); // Clear logical state and SessionStorage

             if (postCallSummaryDiv) postCallSummaryDiv.style.display = 'none';
             if (callFlowViewDiv) callFlowViewDiv.style.display = 'none';
             if (initialViewDiv) {
                 initialViewDiv.style.display = 'block';
                  animateElement(initialViewDiv);
             }
             updateSystemStatus("üî¥ Waiting for Call", "status-waiting");

             if (nextStepBtn) {
                 nextStepBtn.innerHTML = `<span>Next Step</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>`;
                 nextStepBtn.style.display = 'none'; // Ensure hidden
             }
             if (prevStepBtn) prevStepBtn.style.display = 'none';
             if (endCallBtn) endCallBtn.style.display = 'none';
             if (progressTrackerContainer) progressTrackerContainer.style.display = 'none';
             if (callTimerDiv) { callTimerDiv.textContent = '00:00'; callTimerDiv.style.display = 'none'; }
             if (scenarioTitleElement) scenarioTitleElement.textContent = "Call Scenario";
             if (stepsContainer) stepsContainer.innerHTML = '<p class="placeholder-text">Select a scenario to begin.</p>';

              await loadActiveScenarios(); // Reload scenarios
              if (scenarioDropdown) scenarioDropdown.value = "";
              if (receiveCallBtn) receiveCallBtn.disabled = true;

             showAssistantMessage("üí° Ready for the next call! Select a scenario.", true, 'initial', 7000);
         }

        if (returnToInitialViewBtn) {
             returnToInitialViewBtn.addEventListener('click', resetToInitialView);
        }

        // --- 8. ASSISTANT BOX (Typewriter, etc. - Modified for position) ---
        function typeWriterEffect(element, message, speed = 30, callback) {
            if (typingInterval) clearInterval(typingInterval);
            element.textContent = '';
            let i = 0;
            typingInterval = setInterval(() => {
                if (i < message.length) { element.textContent += message.charAt(i); i++; }
                else { clearInterval(typingInterval); typingInterval = null; if (callback) callback(); }
            }, speed);
        }

        // Modified showAssistantMessage to handle position
        function showAssistantMessage(message, showImmediately = false, position = 'call', duration = 5000, onHideCallback) {
            if (assistantMessageElement && assistantBox) {
                clearTimeout(assistantTimeout);
                if (typingInterval) clearInterval(typingInterval); // Stop existing typing

                 const displayMessage = () => {
                     assistantBox.style.display = 'flex'; // Make visible first
                     assistantBox.classList.remove('show', 'slide-in-right', 'assistant-initial-position'); // Clear previous states
                      void assistantBox.offsetWidth; // Trigger reflow

                     // Apply position-specific classes and animations
                     if (position === 'initial') {
                         assistantBox.classList.add('assistant-initial-position');
                         // No slide-in needed for initial static position
                     } else { // Default 'call' position (fixed, bottom-right)
                         assistantBox.classList.add('slide-in-right', 'show');
                     }

                     typeWriterEffect(assistantMessageElement, message, 30, () => {
                         if (duration && duration > 0) {
                             assistantTimeout = setTimeout(() => {
                                 hideAssistant();
                                 if (typeof onHideCallback === 'function') onHideCallback();
                             }, duration);
                         }
                     });
                 };

                 const hideAssistant = () => {
                     if (position === 'initial') {
                         // For initial position, might just fade or hide directly
                         assistantBox.style.display = 'none';
                         assistantBox.classList.remove('assistant-initial-position');
                     } else {
                         assistantBox.classList.remove('show');
                         // Hide after transition
                         setTimeout(() => {
                              if (!assistantBox.classList.contains('show')) {
                                  assistantBox.style.display = 'none';
                              }
                         }, 400); // Match transition duration
                     }
                 }

                 // Always clear previous timeout when showing new message
                 clearTimeout(assistantTimeout);

                 // Determine if we should show immediately or update in place
                 const isCurrentlyVisible = assistantBox.style.display === 'flex' || assistantBox.classList.contains('show');
                 const isCorrectPosition = (position === 'initial' && assistantBox.classList.contains('assistant-initial-position')) ||
                                           (position === 'call' && !assistantBox.classList.contains('assistant-initial-position'));

                 if (!isCurrentlyVisible || !isCorrectPosition || showImmediately) {
                     displayMessage(); // Show from hidden or if forcing immediate display/position change
                 } else {
                      // If already shown in the correct position, just update text
                      typeWriterEffect(assistantMessageElement, message, 30, () => {
                         if (duration && duration > 0) {
                           assistantTimeout = setTimeout(() => {
                                hideAssistant();
                                if (typeof onHideCallback === 'function') onHideCallback();
                            }, duration);
                        }
                    });
                 }
            }
        }


        console.log("CoreFlow.js v2.3 script fully loaded and initialized."); // Version updated
    });
    </script>
</body>
</html>
