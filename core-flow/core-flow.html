<!DOCTYPE html>
<html lang="en" class="dark"> 
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elevo Core Assistant</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%2317a2b8' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M3 12h18M3 6h12M3 18h15'/><path d='M17 9l4 3l-4 3'/></svg>">
    
    <link rel="stylesheet" href="style.css"> <!-- Make sure style.css is in the same directory or path is correct -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
    <div class="app-container">
        <header class="app-header">
            <div class="logo-container">
                <svg class="company-logo" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M6 17L10 17M6 12L12 12M6 7L14 7" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                    <path d="M15 6L19 10L15 14" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <rect x="3" y="3" width="18" height="18" rx="3" stroke="currentColor" stroke-width="1.5" fill="transparent" opacity="0.6"/>
                </svg>
                <span class="app-title">Elevo Core</span>
            </div>
            <div class="header-controls">
                <a href="dashboard.html" class="nav-link">Dashboard</a> 
                <div class="user-info" id="userInfo" style="display: none;">
                    <span id="userName" class="user-name-display"></span>
                    <button id="logoutButton" class="logout-btn">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line></svg>
                        <span>Logout</span>
                    </button>
                </div>
            </div>
        </header>

        <div class="status-bar">
            <div id="systemStatus" class="status-indicator status-waiting">üî¥ Waiting for Call</div>
            <div id="callTimer" class="call-timer" style="display: none;">00:00</div>
        </div>

        <div id="progressTracker" class="progress-tracker-container" style="display: none;">
            <!-- Stepper will be dynamically generated here by JavaScript -->
        </div>

        <main class="app-main">
            <div id="auth-loading" class="loading-container">
                <div class="spinner"></div>
                <p>Initializing Assistant...</p>
            </div>

            <div id="initial-view" class="card initial-card" style="display: none;">
                <div class="card-icon">
                     <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="48" height="48"><path d="M12 2C6.486 2 2 6.486 2 12C2 17.514 6.486 22 12 22C17.514 22 22 17.514 22 12C22 6.486 17.514 2 12 2ZM12 20C7.589 20 4 16.411 4 12C4 7.589 7.589 4 12 4C16.411 4 20 7.589 20 12C20 16.411 16.411 20 12 20Z"/><path d="M12 11C10.897 11 10 10.103 10 9C10 7.897 10.897 7 12 7C13.103 7 14 7.897 14 9C14 10.103 13.103 11 12 11ZM12 9C11.514 9 11.121 9.229 11.038 9.583L12.962 10.417C12.879 10.771 12.486 11 12 11C11.448 11 11 10.552 11 10C11 9.448 11.448 9 12 9Z"/><path d="M16.002 16.246C15.483 15.219 14.544 14.5 13.333 14.5H10.667C9.456 14.5 8.517 15.219 7.998 16.246C7.933 16.386 7.996 16.553 8.114 16.641C8.657 17.053 9.737 17.5 12 17.5C14.263 17.5 15.343 17.053 15.886 16.641C16.004 16.553 16.067 16.386 16.002 16.246Z"/></svg>
                </div>
                <h2 class="card-title">Core Flow Assistant</h2>
                <p class="card-subtitle">Ready to streamline your customer interactions.</p>
                <button id="receive-call-btn" class="action-button primary-button">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M6.05828 11.0452L4.00001 9.00002C4.00001 9.00002 3.58101 8.99902 3.51201 9.00002C2.04801 9.02602 1.00001 10.318 1.00001 11.785V12.214C1.00001 13.682 2.04801 14.973 3.51201 15H4.00001L6.05828 12.9548C6.12828 12.8848 6.16728 12.7948 6.16728 12C6.16728 11.2052 6.12828 11.1152 6.05828 11.0452ZM20.488 15H21C22.464 14.974 23.512 13.682 23.512 12.215V11.785C23.512 10.318 22.464 9.02602 21 9.00002C20.998 8.99902 20 9.00002 20 9.00002L17.9417 11.0452C17.8717 11.1152 17.8327 11.2052 17.8327 12C17.8327 12.7948 17.8717 12.8848 17.9417 12.9548L20.488 15Z"/><path d="M19.6623 5.08431C19.8803 5.08431 20.0943 5.17031 20.2503 5.32631L21.6743 6.74931C21.9863 7.06231 21.9863 7.56731 21.6743 7.87931C19.4003 10.1523 19.4003 13.8473 21.6743 16.1203C21.9863 16.4323 21.9863 16.9373 21.6743 17.2503L20.2503 18.6733C20.0943 18.8293 19.8803 18.9153 19.6623 18.9153C19.4443 18.9153 19.2303 18.8293 19.0743 18.6733C16.2573 15.8563 16.2573 8.14331 19.0743 5.32631C19.2303 5.17031 19.4443 5.08431 19.6623 5.08431ZM4.92575 5.32631C5.52575 4.72631 6.45075 4.72631 7.05075 5.32631C9.86775 8.14331 9.86775 15.8563 7.05075 18.6733C6.89475 18.8293 6.68075 18.9153 6.46275 18.9153C6.24475 18.9153 6.03075 18.8293 5.87475 18.6733L4.45075 17.2503C4.13875 16.9373 4.13875 16.4323 4.45075 16.1203C6.72375 13.8473 6.72375 10.1523 4.45075 7.87931C4.13875 7.56731 4.13875 7.06231 4.45075 6.74931L5.87475 5.32631C5.71875 5.17031 4.76975 5.17031 4.92575 5.32631Z"/></svg>
                    <span>Receive Call</span>
                </button>
            </div>

            <div id="call-flow-view" class="card call-flow-card" style="display: none;">
                <h3 id="scenario-title" class="card-title scenario-title-dynamic">Call Scenario</h3>
                <div id="steps-container" class="steps-area">
                    <p class="placeholder-text">Loading call steps...</p>
                </div>
                <div class="navigation-buttons">
                    <button id="prev-step-btn" class="nav-button secondary-button" style="display: none;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>
                        <span>Previous</span>
                    </button>
                    <button id="next-step-btn" class="nav-button primary-button">
                        <span>Next Step</span>
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>
                    </button>
                </div>
                 <button id="end-call-btn" class="nav-button danger-button" style="display: none;">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                    <span>End Call</span>
                </button>
            </div>
            
            <div id="postCallSummary" class="card post-call-summary-card" style="display: none;">
                <h3 class="card-title">Call Summary</h3>
                <div id="callSummaryContent">
                    <!-- Content will be injected by JS -->
                </div>
                <button id="returnToInitialViewBtn" class="action-button primary-button" style="margin-top: 1.5rem;">New Call</button>
            </div>

            <div id="assistantBox" class="assistant-box" style="display: none;"> 
                <span class="assistant-icon">üí°</span>
                <p id="assistantMessageElement">Welcome to Elevo Core!</p>
            </div>

        </main>

        <footer class="app-footer">
            <p>¬© 2025 Mohamed Elmenisy - Elevo Core. All rights reserved.</p>
        </footer>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', async () => {
        console.log("CoreFlow.js DOMContentLoaded - Final Clean Version with Per-Step Timer & Session Logging");

        const supabaseUrl = 'https://lgcutmuspcaralydycmg.supabase.co';
        const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxnY3V0bXVzcGNhcmFseWR5Y21nIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU0NDY3MDEsImV4cCI6MjA2MTAyMjcwMX0.3u5Y7pkH2NNnnoGLMWVfAa5b8fq88o1itRYnG1K38tE';
        
        let supabase;
        try {
            supabase = window.supabase.createClient(supabaseUrl, supabaseAnonKey);
            console.log("Supabase client initialized in coreFlow.js");
        } catch (error) {
            console.error("Supabase client initialization failed:", error);
            const authLoadingDiv = document.getElementById('auth-loading');
            if (authLoadingDiv) authLoadingDiv.innerHTML = '<p style="color:red;">Error: Could not connect to services.</p>';
            return;
        }

        // DOM Elements
        const authLoadingDiv = document.getElementById('auth-loading');
        const initialViewDiv = document.getElementById('initial-view');
        const callFlowViewDiv = document.getElementById('call-flow-view');
        const receiveCallBtn = document.getElementById('receive-call-btn');
        const stepsContainer = document.getElementById('steps-container');
        const nextStepBtn = document.getElementById('next-step-btn');
        const prevStepBtn = document.getElementById('prev-step-btn');
        const endCallBtn = document.getElementById('end-call-btn');
        const scenarioTitleElement = document.getElementById('scenario-title');
        const userInfoDiv = document.getElementById('userInfo');
        const userNameSpan = document.getElementById('userName');
        const logoutButton = document.getElementById('logoutButton');
        const systemStatusDiv = document.getElementById('systemStatus');
        const callTimerDiv = document.getElementById('callTimer');
        const progressTrackerContainer = document.getElementById('progressTracker');
        const assistantBox = document.getElementById('assistantBox');
        const assistantMessageElement = document.getElementById('assistantMessageElement');
        const postCallSummaryDiv = document.getElementById('postCallSummary');
        const callSummaryContentDiv = document.getElementById('callSummaryContent');
        const returnToInitialViewBtn = document.getElementById('returnToInitialViewBtn');

        // State Variables
        let currentScenarioName = null;
        let currentSteps = [];
        let currentStepIndex = 0;
        let stepTimerInterval = null; 
        let stepStartTime = 0;       
        let stepDurations = [];      
        let currentCallSessionId = null; 
        let assistantTimeout = null;
        let typingInterval = null; 

        // --- 1. CHECK AUTHENTICATION & USER INFO ---
        try {
            const { data: { session }, error: sessionError } = await supabase.auth.getSession();
            if (sessionError) throw sessionError;
            if (!session) {
                const currentPath = window.location.pathname.replace('/elevo-core-flow', '') + window.location.search + window.location.hash;
                // Make sure the path to login.html is correct relative to core-flow.html
                window.location.href = `../legacy/login.html?redirectTo=${encodeURIComponent(currentPath)}`;
                return; 
            }
            console.log('User is authenticated.');
            if (session.user.email && userNameSpan && userInfoDiv) {
                const emailPrefix = session.user.email.split('@')[0];
                userNameSpan.textContent = emailPrefix.charAt(0).toUpperCase() + emailPrefix.slice(1);
                userInfoDiv.style.display = 'flex';
            }
            if(logoutButton) {
                logoutButton.addEventListener('click', async () => { 
                    const { error } = await supabase.auth.signOut();
                    if (error) console.error("Logout error:", error);
                    else window.location.href = '../legacy/login.html'; // Correct path to login
                });
            }
            if (authLoadingDiv) authLoadingDiv.style.display = 'none';
            if (initialViewDiv) initialViewDiv.style.display = 'block';
            updateSystemStatus("üî¥ Waiting for Call");
            showAssistantMessage("Welcome to Elevo Core!", true, 5000, () => {
                if (initialViewDiv && initialViewDiv.style.display === 'block') {
                    showAssistantMessage("üí° Tip: Click 'Receive Call' to start.", true, 0); 
                }
            });
        } catch (error) {
            console.error("Auth error:", error);
            if (authLoadingDiv) authLoadingDiv.innerHTML = `<p style="color:red;">Auth Error: ${error.message}</p>`;
        }

        // --- UTILITY FUNCTIONS ---
        function updateSystemStatus(statusText, statusClass = 'status-waiting') {
            if (systemStatusDiv) {
                systemStatusDiv.textContent = statusText;
                systemStatusDiv.className = `status-indicator ${statusClass}`;
            }
        }
        
        function startStepTimer() {
            if (callTimerDiv) {
                callTimerDiv.style.display = 'block'; 
                callTimerDiv.textContent = '00:00'; 
            }
            stepStartTime = Date.now(); 
            if (stepTimerInterval) clearInterval(stepTimerInterval);
            stepTimerInterval = setInterval(() => {
                const elapsedTime = Math.floor((Date.now() - stepStartTime) / 1000);
                const minutes = String(Math.floor(elapsedTime / 60)).padStart(2, '0');
                const seconds = String(elapsedTime % 60).padStart(2, '0');
                if (callTimerDiv) callTimerDiv.textContent = `${minutes}:${seconds}`;
            }, 1000);
        }

        function stopAndRecordStepTimer() {
            clearInterval(stepTimerInterval);
            stepTimerInterval = null;
            if (stepStartTime > 0 && currentStepIndex >= 0 && currentStepIndex < currentSteps.length) { 
                const duration = Math.floor((Date.now() - stepStartTime) / 1000); 
                stepDurations[currentStepIndex] = (stepDurations[currentStepIndex] || 0) + duration; 
                console.log(`Step ${currentStepIndex + 1} duration recorded: ${duration}s. Accumulated: ${stepDurations[currentStepIndex]}s`);
                stepStartTime = 0; 
            }
        }

        function resetCallSessionState() {
            stopAndRecordStepTimer(); 
            if (callTimerDiv) {
                callTimerDiv.textContent = '00:00';
                callTimerDiv.style.display = 'none';
            }
            stepDurations = [];
            currentCallSessionId = null; 
            console.log("Call session state (durations, session ID) reset.");
        }

        function determineCallQuality(totalDuration, allStepsCompleted, stepsArrayLength, stepDurationsArray) {
            let quality = "Normal"; 
            let reason = "Standard call flow."; 
            if (!allStepsCompleted) { quality = "Bad"; reason = "Call ended prematurely before completing all steps."; }
            else if (stepsArrayLength > 0 && totalDuration < 30 && totalDuration < 60) { quality = "Bad"; reason = "Call duration very short; potentially unresolved or rushed.";}
            else if (totalDuration > 300 && stepsArrayLength > 0) { 
                quality = "Normal"; 
                reason = "Call duration was extended.";
                const longStepThreshold = 120; 
                for (let i = 0; i < stepDurationsArray.length; i++) {
                    if ((stepDurationsArray[i] || 0) > longStepThreshold) {
                        quality = "Bad"; 
                        reason = `Extended duration on step ${i + 1}. Overall call long.`;
                        break;
                    }
                }
            } else if (allStepsCompleted && stepsArrayLength > 0) { // Ensure it's completed and had steps
                 quality = "Good"; reason = "Call completed efficiently within expected parameters.";
            }
            console.log(`Determined Call Quality: ${quality}. Reason: ${reason}`);
            return { quality, reason }; 
        }

        function renderProgressTracker() { 
            if (!progressTrackerContainer || currentSteps.length === 0) {
                if(progressTrackerContainer) progressTrackerContainer.style.display = 'none';
                return;
            }
            progressTrackerContainer.innerHTML = ''; 
            const stepperUl = document.createElement('ul');
            stepperUl.className = 'stepper';
            currentSteps.forEach((step, index) => {
                const stepLi = document.createElement('li');
                stepLi.className = 'step';
                if (index < currentStepIndex) stepLi.classList.add('completed');
                else if (index === currentStepIndex) stepLi.classList.add('active');
                stepLi.textContent = `Step ${index + 1}`; 
                stepperUl.appendChild(stepLi);
                if (index < currentSteps.length - 1) {
                    const separator = document.createElement('li');
                    separator.className = 'step-separator';
                    separator.innerHTML = '‚Üí'; 
                    stepperUl.appendChild(separator);
                }
            });
            progressTrackerContainer.appendChild(stepperUl);
            progressTrackerContainer.style.display = 'block'; 
        }

        function typeWriterEffect(element, message, speed = 30, callback) { 
            if (typingInterval) clearInterval(typingInterval); 
            element.textContent = ''; 
            let i = 0;
            typingInterval = setInterval(() => {
                if (i < message.length) { element.textContent += message.charAt(i); i++; } 
                else { clearInterval(typingInterval); typingInterval = null; if (callback) callback(); }
            }, speed);
        }

        function showAssistantMessage(message, showImmediately = false, duration = 5000, onHideCallback) { 
            if (assistantMessageElement && assistantBox) {
                clearTimeout(assistantTimeout);
                if (typingInterval) clearInterval(typingInterval); 
                const showBox = () => {
                    assistantBox.style.display = 'flex'; 
                    requestAnimationFrame(() => { assistantBox.classList.add('show'); });
                    typeWriterEffect(assistantMessageElement, message, 30, () => { 
                        if (duration && duration > 0) {
                            assistantTimeout = setTimeout(() => {
                                assistantBox.classList.remove('show');
                                // Only call onHideCallback if it's a function
                                if (typeof onHideCallback === 'function') onHideCallback();
                            }, duration);
                        }
                    });
                };
                if (showImmediately || !assistantBox.classList.contains('show')) showBox();
                else if (assistantBox.classList.contains('show')) { 
                     typeWriterEffect(assistantMessageElement, message, 30, () => {
                        if (duration && duration > 0) {
                           assistantTimeout = setTimeout(() => {
                                assistantBox.classList.remove('show');
                                if (typeof onHideCallback === 'function') onHideCallback();
                            }, duration);
                        }
                    });
                }
            }
        }
        
        function displayPostCallSummary(quality, reason, totalDuration) {
            if (callFlowViewDiv) callFlowViewDiv.style.display = 'none';
            if (progressTrackerContainer) progressTrackerContainer.style.display = 'none';
            if (callTimerDiv) callTimerDiv.style.display = 'none'; 
            if (assistantBox) assistantBox.classList.remove('show');

            if (callSummaryContentDiv && postCallSummaryDiv) {
                let summaryHTML = `
                    <p><strong>Call Quality:</strong> <span class="quality-text quality-${quality.toLowerCase()}">${quality}</span></p>
                    <p><strong>Reason:</strong> ${reason || "N/A"}</p>
                    <p><strong>Total Duration:</strong> ${Math.floor(totalDuration / 60)}m ${totalDuration % 60}s</p>
                    <hr style="margin: 1rem 0; border-color: var(--border-color);">
                    <p><strong>Step Durations:</strong></p>
                    <ul style="list-style: none; padding-left: 0; max-height: 150px; overflow-y: auto;">`;
                
                currentSteps.forEach((stepText, index) => {
                    summaryHTML += `<li style="margin-bottom: 0.3rem;">Step ${index + 1} ("${stepText.length > 20 ? stepText.substring(0, 17) + "..." : stepText}"): ${Math.floor((stepDurations[index] || 0) / 60)}m ${(stepDurations[index] || 0) % 60}s</li>`;
                });
                summaryHTML += `</ul>`;
                
                callSummaryContentDiv.innerHTML = summaryHTML;
                postCallSummaryDiv.style.display = 'block';
            }
            updateSystemStatus("üìä Review Call Summary", "status-completed"); 
        }

        if (returnToInitialViewBtn) {
            returnToInitialViewBtn.addEventListener('click', () => {
                if (postCallSummaryDiv) postCallSummaryDiv.style.display = 'none';
                if (initialViewDiv) initialViewDiv.style.display = 'block';
                updateSystemStatus("üî¥ Waiting for Call");
                
                if (nextStepBtn) { 
                    nextStepBtn.innerHTML = `<span>Next Step</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>`;
                    nextStepBtn.style.display = 'none'; 
                }
                if (prevStepBtn) prevStepBtn.style.display = 'none';
                if (endCallBtn) endCallBtn.style.display = 'none'; 
                if (progressTrackerContainer) progressTrackerContainer.style.display = 'none';
                if (callTimerDiv) { callTimerDiv.textContent = '00:00'; callTimerDiv.style.display = 'none'; }
                if (scenarioTitleElement) scenarioTitleElement.textContent = "Call Scenario"; 
                if (stepsContainer) stepsContainer.innerHTML = '<p class="placeholder-text">Ready for a new call.</p>';

                showAssistantMessage("üí° Ready for the next call!", true, 7000, () => {
                    if (initialViewDiv && initialViewDiv.style.display === 'block') {
                        showAssistantMessage("üí° Tip: Click 'Receive Call' to start.", true, 0);
                    }
                });
            });
        }

        // --- 2. "RECEIVE CALL" BUTTON FUNCTIONALITY ---
        if (receiveCallBtn) {
            receiveCallBtn.addEventListener('click', async () => {
                console.log("Receive Call button clicked");
                resetCallSessionState(); 
                if (initialViewDiv) initialViewDiv.style.display = 'none';
                if (callFlowViewDiv) callFlowViewDiv.style.display = 'block';
                if (endCallBtn) endCallBtn.style.display = 'inline-flex';
                updateSystemStatus("üü° Loading Scenario...", "status-waiting");
                if (stepsContainer) stepsContainer.innerHTML = '<p class="placeholder-text">Loading scenario...</p>';
                if (scenarioTitleElement) scenarioTitleElement.textContent = 'Loading Scenario...';
                if (progressTrackerContainer) progressTrackerContainer.style.display = 'none';
                if (nextStepBtn) nextStepBtn.style.display = 'none';
                if (prevStepBtn) prevStepBtn.style.display = 'none';

                try {
                    const { data: { user } } = await supabase.auth.getUser(); 
                    if (!user) throw new Error("User not identified. Cannot start call.");

                    const { data: scenario, error: scenarioError } = await supabase
                        .from('call_scenarios').select('id, name, steps').eq('is_active', true).limit(1).single();             
                    if (scenarioError) throw scenarioError;
                    if (!scenario || !scenario.steps || scenario.steps.length === 0) throw new Error("Loaded scenario is invalid or has no steps.");

                    currentScenarioName = scenario.name;
                    currentSteps = scenario.steps; 
                    currentStepIndex = 0;
                    stepDurations = new Array(currentSteps.length).fill(0); 

                    const { data: newSession, error: sessionInsertError } = await supabase
                        .from('call_sessions')
                        .insert({ user_id: user.id, scenario_id: scenario.id, start_time: new Date().toISOString(), completed_all_steps: false })
                        .select('id').single();
                    if (sessionInsertError || !newSession) throw sessionInsertError || new Error("Failed to create session record.");
                    
                    currentCallSessionId = newSession.id; 
                    console.log("New call session created with ID:", currentCallSessionId);

                    if (scenarioTitleElement) scenarioTitleElement.textContent = currentScenarioName;
                    updateSystemStatus("üü¢ In Call", "status-in-call");
                    renderProgressTracker();
                    renderStep(); 
                    showAssistantMessage(`üöÄ Scenario "${currentScenarioName}" started!`, true, 0);

                } catch (err) {
                    console.error("Error during call setup:", err);
                    if (callTimerDiv) callTimerDiv.style.display = 'none';
                    let userMessage = `‚ö†Ô∏è Error: ${err.message}`;
                    if (err.code === 'PGRST116') userMessage = "‚ö†Ô∏è No active scenario found.";
                    
                    if (stepsContainer) stepsContainer.innerHTML = `<p style="color:red;">${userMessage.substring(3)}</p>`;
                    if (scenarioTitleElement) scenarioTitleElement.textContent = 'Error Loading';
                    updateSystemStatus("üî¥ Error", "status-waiting");
                    showAssistantMessage(userMessage, true, 7000);
                    if (callFlowViewDiv) callFlowViewDiv.style.display = 'none';
                    if (initialViewDiv) initialViewDiv.style.display = 'block';
                    if (endCallBtn) endCallBtn.style.display = 'none';
                }
            });
        }

        // --- 3. RENDER STEP FUNCTION ---
        function renderStep() {
            if (!stepsContainer) return;
            if (currentSteps.length === 0) { 
                stepsContainer.innerHTML = '<p class="placeholder-text">No steps available.</p>';
                if (nextStepBtn) nextStepBtn.style.display = 'none';
                if (prevStepBtn) prevStepBtn.style.display = 'none';
                return;
            }
            if (currentStepIndex >= 0 && currentStepIndex < currentSteps.length) {
                const stepContent = currentSteps[currentStepIndex];
                stepsContainer.innerHTML = `<p>${stepContent}</p>`;
                showAssistantMessage(`üìå ${stepContent.length > 45 ? stepContent.substring(0, 42) + "..." : stepContent}`, true, 0); 
                startStepTimer(); 
            }
            renderProgressTracker(); 
            if (prevStepBtn) prevStepBtn.style.display = currentStepIndex > 0 ? 'inline-flex' : 'none';
            if (nextStepBtn) {
                if (currentStepIndex < currentSteps.length - 1) {
                    nextStepBtn.innerHTML = `<span>Next Step</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>`;
                    nextStepBtn.style.display = 'inline-flex';
                } else if (currentStepIndex === currentSteps.length - 1) {
                    nextStepBtn.innerHTML = `<span>Finish Scenario</span>`; 
                    nextStepBtn.style.display = 'inline-flex';
                } else { 
                    nextStepBtn.style.display = 'none';
                }
            }
        }

        // --- 4. NAVIGATION BUTTONS ---
        if (nextStepBtn) {
            nextStepBtn.addEventListener('click', async () => { 
                stopAndRecordStepTimer(); 
                if (currentStepIndex < currentSteps.length - 1) {
                    currentStepIndex++;
                    renderStep();
                } else if (currentStepIndex === currentSteps.length - 1) { 
                    console.log(`Scenario ${currentScenarioName} fully completed by user.`);
                    updateSystemStatus("‚úÖ Call Completed", "status-completed");
                    
                    let totalDuration = stepDurations.reduce((acc, duration) => acc + (duration || 0), 0);
                    const { quality, reason } = determineCallQuality(totalDuration, true, currentSteps.length, stepDurations); 

                    if (currentCallSessionId) {
                        const { error: updateError } = await supabase
                            .from('call_sessions')
                            .update({ 
                                end_time: new Date().toISOString(), 
                                total_duration_seconds: totalDuration, 
                                completed_all_steps: true,
                                call_quality: quality, 
                                quality_reason: reason 
                            })
                            .eq('id', currentCallSessionId);
                        if (updateError) console.error("Failed to update call session on completion:", updateError);
                        else console.log("Call session updated on FULL completion. ID:", currentCallSessionId);
                    }
                    
                    displayPostCallSummary(quality, reason, totalDuration);
                    
                    if (nextStepBtn) nextStepBtn.style.display = 'none';
                    if (prevStepBtn) prevStepBtn.style.display = 'none'; // Hide prev as well on full completion
                    if (endCallBtn) endCallBtn.style.display = 'none'; 
                }
            });
        }

        if (prevStepBtn) {
            prevStepBtn.addEventListener('click', () => { 
                stopAndRecordStepTimer(); 
                if (currentStepIndex > 0) {
                    currentStepIndex--;
                    renderStep();
                }
            });
        }
        
        // --- 5. END CALL BUTTON ---
        if (endCallBtn) {
            endCallBtn.addEventListener('click', async () => { 
                stopAndRecordStepTimer(); 
                let totalDuration = stepDurations.reduce((acc, duration) => acc + (duration || 0), 0);
                console.log("End Call button clicked by user.");

                if (currentCallSessionId) {
                    // Determine if scenario was "effectively" completed.
                    // This happens if the user is on the last step and clicks "End Call" 
                    // (perhaps because the "Finish Scenario" button does the same as end call in this context).
                    // Or if they had already clicked "Finish Scenario" which hides nextStepBtn.
                    const isScenarioEffectivelyCompleted = 
                        (currentSteps.length > 0 && currentStepIndex >= currentSteps.length - 1);
                    
                    const { quality, reason } = determineCallQuality(totalDuration, isScenarioEffectivelyCompleted, currentSteps.length, stepDurations);

                    const { error: updateError } = await supabase
                        .from('call_sessions')
                        .update({
                            end_time: new Date().toISOString(),
                            total_duration_seconds: totalDuration,
                            completed_all_steps: isScenarioEffectivelyCompleted,
                            call_quality: quality,
                            quality_reason: reason 
                        })
                        .eq('id', currentCallSessionId);
                    if (updateError) console.error("Failed to update call session on end call:", updateError);
                    else console.log(`Call session ${currentCallSessionId} updated on end call. Completed: ${isScenarioEffectivelyCompleted}, Quality: ${quality}`);
                    
                    displayPostCallSummary(quality, reason, totalDuration);
                } else {
                    resetCallSessionState(); 
                    if (callFlowViewDiv) callFlowViewDiv.style.display = 'none';
                    if (initialViewDiv) initialViewDiv.style.display = 'block';
                    updateSystemStatus("üî¥ Waiting for Call");
                }
                 // Hide call flow buttons as summary is now shown
                if (nextStepBtn) nextStepBtn.style.display = 'none';
                if (prevStepBtn) prevStepBtn.style.display = 'none';
                if (endCallBtn) endCallBtn.style.display = 'none';
            });
        }

        console.log("CoreFlow.js script fully loaded - Final Clean with Post-Call Summary.");
    });
    </script>
</body>
</html>
