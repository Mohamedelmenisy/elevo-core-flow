<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elevo Core Assistant</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%2317a2b8' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><path d='M3 12h18M3 6h12M3 18h15'/><path d='M17 9l4 3l-4 3'/></svg>">

    <link rel="stylesheet" href="style.css"> <!-- Ensure style.css path is correct -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
    <audio id="callStartSound" src="sounds/call_start.mp3" preload="auto"></audio>

    <div class="app-container">
        <header class="app-header">
            <div class="logo-container">
                <svg class="company-logo" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M6 17L10 17M6 12L12 12M6 7L14 7" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                    <path d="M15 6L19 10L15 14" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <rect x="3" y="3" width="18" height="18" rx="3" stroke="currentColor" stroke-width="1.5" fill="transparent" opacity="0.6"/>
                </svg>
                <span class="app-title">Elevo Core</span>
            </div>
            <div class="header-controls">
                 <a href="dashboard.html" class="nav-link">Dashboard</a>
                <div class="user-info" id="userInfo" style="display: none;">
                    <span id="userName" class="user-name-display"></span>
                    <button id="logoutButton" class="logout-btn">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line></svg>
                        <span>Logout</span>
                    </button>
                </div>
            </div>
        </header>

        <div class="status-bar">
            <div id="systemStatus" class="status-indicator status-waiting">üî¥ Waiting for Call</div>
        </div>

        <div id="progressTracker" class="progress-tracker-container" style="display: none;">
             <div class="stepper-wrapper">
                 <!-- Stepper will be dynamically generated here -->
            </div>
        </div>

         <div id="timer-container">
             <div id="callTimer" style="display: none;">00:00</div>
         </div>

        <main class="app-main">
            <div id="auth-loading" class="loading-container">
                <div class="spinner"></div>
                <p>Initializing Assistant...</p>
            </div>

            <div id="initial-view" class="card initial-card fade-in" style="display: none;">
                <div class="card-icon">
                     <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="48" height="48"><path d="M12 2C6.486 2 2 6.486 2 12C2 17.514 6.486 22 12 22C17.514 22 22 17.514 22 12C22 6.486 17.514 2 12 2ZM12 20C7.589 20 4 16.411 4 12C4 7.589 7.589 4 12 4C16.411 4 20 7.589 20 12C20 16.411 16.411 20 12 20Z"/><path d="M12 11C10.897 11 10 10.103 10 9C10 7.897 10.897 7 12 7C13.103 7 14 7.897 14 9C14 10.103 13.103 11 12 11ZM12 9C11.514 9 11.121 9.229 11.038 9.583L12.962 10.417C12.879 10.771 12.486 11 12 11C11.448 11 11 10.552 11 10C11 9.448 11.448 9 12 9Z"/><path d="M16.002 16.246C15.483 15.219 14.544 14.5 13.333 14.5H10.667C9.456 14.5 8.517 15.219 7.998 16.246C7.933 16.386 7.996 16.553 8.114 16.641C8.657 17.053 9.737 17.5 12 17.5C14.263 17.5 15.343 17.053 15.886 16.641C16.004 16.553 16.067 16.386 16.002 16.246Z"/></svg>
                </div>
                <h2 class="card-title">Core Flow Assistant</h2>
                <p class="card-subtitle">Select a scenario and receive the call.</p>

                <div class="scenario-selector-container">
                    <label for="scenarioDropdown">Select Scenario:</label>
                    <select id="scenarioDropdown" class="scenario-dropdown">
                        <option value="">Loading scenarios...</option>
                    </select>
                </div>

                <div id="assistantBox" class="assistant-box assistant-initial-position" style="display: none;">
                    <span class="assistant-icon">üí°</span>
                    <p id="assistantMessageElement">Welcome to Elevo Core!</p>
                </div>

                <button id="receive-call-btn" class="action-button primary-button" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="20" height="20"><path d="M6.05828 11.0452L4.00001 9.00002C4.00001 9.00002 3.58101 8.99902 3.51201 9.00002C2.04801 9.02602 1.00001 10.318 1.00001 11.785V12.214C1.00001 13.682 2.04801 14.973 3.51201 15H4.00001L6.05828 12.9548C6.12828 12.8848 6.16728 12.7948 6.16728 12C6.16728 11.2052 6.12828 11.1152 6.05828 11.0452ZM20.488 15H21C22.464 14.974 23.512 13.682 23.512 12.215V11.785C23.512 10.318 22.464 9.02602 21 9.00002C20.998 8.99902 20 9.00002 20 9.00002L17.9417 11.0452C17.8717 11.1152 17.8327 11.2052 17.8327 12C17.8327 12.7948 17.8717 12.8848 17.9417 12.9548L20.488 15Z"/><path d="M19.6623 5.08431C19.8803 5.08431 20.0943 5.17031 20.2503 5.32631L21.6743 6.74931C21.9863 7.06231 21.9863 7.56731 21.6743 7.87931C19.4003 10.1523 19.4003 13.8473 21.6743 16.1203C21.9863 16.4323 21.9863 16.9373 21.6743 17.2503L20.2503 18.6733C20.0943 18.8293 19.8803 18.9153 19.6623 18.9153C19.4443 18.9153 19.2303 18.8293 19.0743 18.6733C16.2573 15.8563 16.2573 8.14331 19.0743 5.32631C19.2303 5.17031 19.4443 5.08431 19.6623 5.08431ZM4.92575 5.32631C5.52575 4.72631 6.45075 4.72631 7.05075 5.32631C9.86775 8.14331 9.86775 15.8563 7.05075 18.6733C6.89475 18.8293 6.68075 18.9153 6.46275 18.9153C6.24475 18.9153 6.03075 18.8293 5.87475 18.6733L4.45075 17.2503C4.13875 16.9373 4.13875 16.4323 4.45075 16.1203C6.72375 13.8473 6.72375 10.1523 4.45075 7.87931C4.13875 7.56731 4.13875 7.06231 4.45075 6.74931L5.87475 5.32631C5.71875 5.17031 4.76975 5.17031 4.92575 5.32631Z"/></svg>
                    <span>Receive Call</span>
                </button>
            </div>

            <div id="call-flow-view" class="card call-flow-card fade-in" style="display: none;">
                <h3 id="scenario-title" class="card-title scenario-title-dynamic">Call Scenario</h3>
                <div id="steps-container" class="steps-area">
                    <p class="placeholder-text">Loading call steps...</p>
                </div>
                <div class="navigation-buttons">
                    <button id="prev-step-btn" class="nav-button secondary-button" style="display: none;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"></polyline></svg>
                        <span>Previous</span>
                    </button>
                    <button id="next-step-btn" class="nav-button primary-button">
                        <span>Next Step</span>
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>
                    </button>
                </div>
                 <button id="end-call-btn" class="nav-button danger-button" style="display: none;">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                    <span>End Call</span>
                </button>
            </div>

            <div id="postCallSummary" class="card post-call-summary-card fade-in" style="display: none;">
                <h3 class="card-title">Call Summary</h3>
                <div id="callSummaryContent">
                    <!-- Content will be injected by JS -->
                </div>
                <button id="returnToInitialViewBtn" class="action-button primary-button" style="margin-top: 1.5rem;">New Call</button>
            </div>
        </main>

        <footer class="app-footer">
            <p>¬© <span id="currentYear"></span> Mohamed Elmenisy - Elevo Core. All rights reserved.</p>
        </footer>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', async () => {
        console.log("Elevo Core Assistant Initializing - v3.0 (Clean Rebuild)");
        document.getElementById('currentYear').textContent = new Date().getFullYear();

        // --- Supabase Client Initialization ---
        const supabaseUrl = 'https://lgcutmuspcaralydycmg.supabase.co';
        const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxnY3V0bXVzcGNhcmFseWR5Y21nIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU0NDY3MDEsImV4cCI6MjA2MTAyMjcwMX0.DX9NNZPYMaV96D1ohW9pwFWLzywKLYjP5s6tP89PLdbX';
        let supabase;
        try {
            supabase = window.supabase.createClient(supabaseUrl, supabaseAnonKey);
            console.log("Supabase client initialized.");
        } catch (error) {
            console.error("Supabase client initialization failed:", error);
            document.getElementById('auth-loading').innerHTML = '<p style="color:red;">Error: Could not connect to services. Please refresh.</p>';
            return;
        }

        // --- DOM Elements ---
        const authLoadingDiv = document.getElementById('auth-loading');
        const initialViewDiv = document.getElementById('initial-view');
        const callFlowViewDiv = document.getElementById('call-flow-view');
        const scenarioDropdown = document.getElementById('scenarioDropdown');
        const receiveCallBtn = document.getElementById('receive-call-btn');
        const stepsContainer = document.getElementById('steps-container');
        const nextStepBtn = document.getElementById('next-step-btn');
        const prevStepBtn = document.getElementById('prev-step-btn');
        const endCallBtn = document.getElementById('end-call-btn');
        const scenarioTitleElement = document.getElementById('scenario-title');
        const userInfoDiv = document.getElementById('userInfo');
        const userNameSpan = document.getElementById('userName');
        const logoutButton = document.getElementById('logoutButton');
        const systemStatusDiv = document.getElementById('systemStatus');
        const callTimerDiv = document.getElementById('callTimer');
        const progressTrackerContainer = document.getElementById('progressTracker');
        const assistantBox = document.getElementById('assistantBox');
        const assistantMessageElement = document.getElementById('assistantMessageElement');
        const postCallSummaryDiv = document.getElementById('postCallSummary');
        const callSummaryContentDiv = document.getElementById('callSummaryContent');
        const returnToInitialViewBtn = document.getElementById('returnToInitialViewBtn');
        const callStartSound = document.getElementById('callStartSound');

        // --- State Variables ---
        let currentCallSessionId = null; // ID of the current call_sessions record
        let currentScenarioId = null;
        let currentScenarioName = null;
        let currentSteps = [];
        let currentStepIndex = 0;
        let stepDurations = []; // Stores accumulated seconds for each step index
        let stepTimerInterval = null;
        let stepStartTime = 0; // Timestamp for when the current step's timer started
        let totalElapsedSecondsOnLoad = 0; // For restoring timer after page reload
        let availableScenarios = []; // To store fetched scenarios
        const SESSION_STATE_KEY = 'elevoCoreActiveCallState_v3'; // Updated key for sessionStorage
        let assistantTimeout = null;
        let typingInterval = null;

        // --- Helper: Animation ---
        function animateElement(element, animationClass = 'fade-in') {
            if (element) {
                element.classList.remove(animationClass);
                void element.offsetWidth; // Trigger reflow
                element.classList.add(animationClass);
            }
        }

        // --- Helper: Update System Status ---
        function updateSystemStatus(statusText, statusClass = 'status-waiting') {
            if (systemStatusDiv) {
                systemStatusDiv.textContent = statusText;
                systemStatusDiv.className = `status-indicator ${statusClass}`;
            }
        }

        // --- Session State Persistence ---
        function saveCallState() {
            if (!currentCallSessionId) return; // Don't save if no active call session
            const state = {
                sessionId: currentCallSessionId,
                scenarioId: currentScenarioId,
                scenarioName: currentScenarioName,
                steps: currentSteps,
                stepIndex: currentStepIndex,
                durations: stepDurations,
                stepStartTime: stepStartTime, // Save the start time of the current step's timer
                timestamp: Date.now()
            };
            try {
                sessionStorage.setItem(SESSION_STATE_KEY, JSON.stringify(state));
                console.log("Call state saved:", state);
            } catch (e) {
                console.error("Error saving call state to SessionStorage:", e);
            }
        }

        function loadCallState() {
            try {
                const savedState = sessionStorage.getItem(SESSION_STATE_KEY);
                if (savedState) {
                    const state = JSON.parse(savedState);
                    console.log("Found saved call state:", state);

                    currentCallSessionId = state.sessionId;
                    currentScenarioId = state.scenarioId;
                    currentScenarioName = state.scenarioName;
                    currentSteps = state.steps || [];
                    currentStepIndex = state.stepIndex !== undefined ? state.stepIndex : 0;
                    stepDurations = state.durations || new Array(currentSteps.length).fill(0);
                    stepStartTime = state.stepStartTime || 0; // Restore the timer's start time

                    if (stepStartTime > 0) {
                        totalElapsedSecondsOnLoad = Math.floor((Date.now() - stepStartTime) / 1000);
                        console.log(`Restored step timer started at ${new Date(stepStartTime)}, ${totalElapsedSecondsOnLoad}s already elapsed.`);
                    } else {
                        totalElapsedSecondsOnLoad = 0;
                    }
                    return true; // State loaded
                }
            } catch (e) {
                console.error("Error loading call state from SessionStorage:", e);
                clearCallState(); // Clear potentially corrupted state
            }
            return false; // No state loaded
        }

        function clearCallState() {
            sessionStorage.removeItem(SESSION_STATE_KEY);
            console.log("Call state cleared from SessionStorage.");
        }

        // --- Initial Authentication Check and App Setup ---
        try {
            const { data: { session }, error: sessionError } = await supabase.auth.getSession();
            if (sessionError) {
                console.error("Error getting session:", sessionError);
                throw sessionError; // Let the catch block handle UI update
            }

            const isOnLoginPage = window.location.pathname.includes("login.html");

            if (!session && !isOnLoginPage) {
                console.log("No session and not on login page. Redirecting to login.");
                const redirectTo = encodeURIComponent(window.location.pathname + window.location.search);
                window.location.href = `login.html?redirectTo=${redirectTo}`;
                return; // Stop script execution for this page
            }

            if (!session && isOnLoginPage) {
                // This script is for core-flow.html. If there's no session and we are on login.html,
                // this script should not run its main logic. login.html has its own script.
                console.log("No session, but already on login page. Halting core-flow.html script logic.");
                if (authLoadingDiv) authLoadingDiv.style.display = 'none'; // Hide loading spinner
                return; // Stop further execution of this script
            }

            // If we reach here, a session exists.
            console.log('User is authenticated. Session:', session);
            if (session.user.email && userNameSpan && userInfoDiv) {
                const emailPrefix = session.user.email.split('@')[0];
                userNameSpan.textContent = emailPrefix.charAt(0).toUpperCase() + emailPrefix.slice(1);
                userInfoDiv.style.display = 'flex';
            }

            if (logoutButton) {
                logoutButton.addEventListener('click', async () => {
                    clearCallState(); // Clear any active call state
                    const { error } = await supabase.auth.signOut();
                    if (error) console.error("Logout error:", error);
                    // Always redirect to login after logout, with a default redirectTo core-flow
                    window.location.href = 'login.html?redirectTo=core-flow.html';
                });
            }

            if (authLoadingDiv) authLoadingDiv.style.display = 'none';

            if (loadCallState() && currentCallSessionId && currentSteps.length > 0) {
                console.log("Restoring active call session...");
                if (initialViewDiv) initialViewDiv.style.display = 'none';
                if (callFlowViewDiv) callFlowViewDiv.style.display = 'block';
                if (scenarioTitleElement) scenarioTitleElement.textContent = currentScenarioName || 'Restored Scenario';
                updateSystemStatus("üü¢ In Call (Restored)", "status-in-call");
                if (endCallBtn) endCallBtn.style.display = 'inline-flex';
                renderProgressTracker();
                renderStep(); // This will also restart the timer correctly
            } else {
                console.log("No active call state found or state invalid. Loading initial view.");
                clearCallState(); // Ensure any invalid state is cleared
                await loadActiveScenarios();
                if (initialViewDiv) {
                    initialViewDiv.style.display = 'block';
                    animateElement(initialViewDiv);
                }
                updateSystemStatus("üî¥ Waiting for Call");
                showAssistantMessage("Welcome! Select a scenario to begin.", true, 'initial', 6000, () => {
                    if (initialViewDiv && initialViewDiv.style.display === 'block') {
                        showAssistantMessage("üí° Tip: Choose a scenario and click 'Receive Call'.", true, 'initial', 0);
                    }
                });
            }

        } catch (error) {
            console.error("Authentication or Initial Load/Restore error:", error);
            if (authLoadingDiv) authLoadingDiv.innerHTML = `<p style="color:var(--danger-color);">Initialization Error: ${error.message}. Please refresh.</p>`;
            updateSystemStatus("üî¥ Error", "status-error");
            clearCallState(); // Clear state on error
        }

        // --- Load Active Scenarios ---
        async function loadActiveScenarios() {
            if (!scenarioDropdown || !receiveCallBtn) return;
            scenarioDropdown.disabled = true;
            receiveCallBtn.disabled = true;
            scenarioDropdown.innerHTML = '<option value="">Loading scenarios...</option>';

            try {
                const { data: scenarios, error } = await supabase
                    .from('call_scenarios')
                    .select('id, title') // Fetching 'title' instead of 'name'
                    .eq('is_active', true)
                    .order('title', { ascending: true }); // Ordering by 'title'

                if (error) throw error;

                availableScenarios = scenarios || [];
                scenarioDropdown.innerHTML = '<option value="">-- Select a Scenario --</option>';

                if (availableScenarios.length > 0) {
                    availableScenarios.forEach(scenario => {
                        const option = document.createElement('option');
                        option.value = scenario.id;
                        option.textContent = scenario.title; // Using 'title'
                        scenarioDropdown.appendChild(option);
                    });
                    scenarioDropdown.disabled = false;
                } else {
                    scenarioDropdown.innerHTML = '<option value="">No active scenarios found</option>';
                    showAssistantMessage("‚ö†Ô∏è No active call scenarios available.", true, 'initial', 0);
                }
            } catch (err) {
                console.error("Error loading scenarios:", err);
                scenarioDropdown.innerHTML = '<option value="">Error loading scenarios</option>';
                showAssistantMessage(`‚ö†Ô∏è Error loading scenarios: ${err.message}`, true, 'initial', 8000);
            }
        }
        if (scenarioDropdown) {
            scenarioDropdown.addEventListener('change', () => {
                 if(receiveCallBtn) receiveCallBtn.disabled = !scenarioDropdown.value;
            });
        }


        // --- Timer Management ---
        function startStepTimer() {
            if (callTimerDiv) callTimerDiv.style.display = 'inline-block';
            if (stepTimerInterval) clearInterval(stepTimerInterval);

            // If stepStartTime is 0, it means we are starting this step's timer fresh.
            // If stepStartTime is > 0, it means we are resuming (e.g., from page load or navigating back).
            if (stepStartTime === 0) {
                stepStartTime = Date.now(); // Fresh start for this step's segment
                console.log(`Timer: Fresh start for step ${currentStepIndex + 1} at ${new Date(stepStartTime)}`);
            } else {
                 console.log(`Timer: Resuming for step ${currentStepIndex + 1}. Original timer start: ${new Date(stepStartTime)}, elapsed on load: ${totalElapsedSecondsOnLoad}s`);
            }

            saveCallState(); // Save state with potentially new stepStartTime

            const updateDisplay = () => {
                // Calculate elapsed time since the timer for *this specific step segment* started
                const currentSegmentElapsedTime = Math.floor((Date.now() - stepStartTime) / 1000);
                // If totalElapsedSecondsOnLoad is > 0, it means we are restoring from a page load,
                // so add that pre-elapsed time to the current segment's time.
                const totalSecondsForThisStepDisplay = currentSegmentElapsedTime + (totalElapsedSecondsOnLoad || 0);

                const minutes = String(Math.floor(totalSecondsForThisStepDisplay / 60)).padStart(2, '0');
                const seconds = String(totalSecondsForThisStepDisplay % 60).padStart(2, '0');
                if (callTimerDiv) callTimerDiv.textContent = `${minutes}:${seconds}`;
            };

            updateDisplay(); // Initial display
            stepTimerInterval = setInterval(updateDisplay, 1000);
        }

        function stopAndRecordStepTimer() {
            clearInterval(stepTimerInterval);
            stepTimerInterval = null;

            if (stepStartTime > 0 && currentStepIndex >= 0 && currentStepIndex < currentSteps.length) {
                // Duration is time from stepStartTime to now, PLUS any time already elapsed if restoring from load
                const durationForThisSegment = Math.floor((Date.now() - stepStartTime) / 1000);
                const totalDurationForThisStep = durationForThisSegment + totalElapsedSecondsOnLoad;

                if (!stepDurations) stepDurations = new Array(currentSteps.length).fill(0);

                // This logic assumes stepDurations[currentStepIndex] might have prior time if user navigates back and forth.
                // For this app, we are replacing the duration for the step each time it's "completed" by moving next or ending.
                // A simpler approach if we only care about the *last* time spent on a step:
                stepDurations[currentStepIndex] = totalDurationForThisStep;
                console.log(`Timer: Step ${currentStepIndex + 1} duration recorded: ${totalDurationForThisStep}s.`);

            }
            stepStartTime = 0; // Reset for the next step's timer
            totalElapsedSecondsOnLoad = 0; // Reset this as well
            saveCallState(); // Save durations and reset timer state
        }

        function resetCallUIDandState() {
            if (stepTimerInterval) clearInterval(stepTimerInterval);
            stepTimerInterval = null;

            if (callTimerDiv) {
                callTimerDiv.textContent = '00:00';
                callTimerDiv.style.display = 'none';
            }
            if (progressTrackerContainer) progressTrackerContainer.style.display = 'none';

            // Logical state reset
            currentCallSessionId = null;
            currentScenarioId = null;
            currentScenarioName = null;
            currentSteps = [];
            currentStepIndex = 0;
            stepDurations = [];
            stepStartTime = 0;
            totalElapsedSecondsOnLoad = 0;

            clearCallState(); // Clear from SessionStorage
            console.log("Call session state and UI reset.");
        }


        // --- Render Step & Progress Tracker ---
        function renderProgressTracker() {
            if (!progressTrackerContainer || currentSteps.length === 0) {
                if(progressTrackerContainer) progressTrackerContainer.style.display = 'none';
                return;
            }
            const stepperWrapper = progressTrackerContainer.querySelector('.stepper-wrapper');
            if (!stepperWrapper) return;
            stepperWrapper.innerHTML = '';

            const stepperUl = document.createElement('ul');
            stepperUl.className = 'stepper';

            currentSteps.forEach((_, index) => {
                const stepLi = document.createElement('li');
                stepLi.className = 'step';
                const stepNumber = document.createElement('span');
                stepNumber.className = 'step-number';
                stepNumber.textContent = index + 1;
                stepLi.appendChild(stepNumber);

                if (index < currentStepIndex) {
                    stepLi.classList.add('completed');
                    stepNumber.innerHTML = '‚úì'; // Checkmark
                } else if (index === currentStepIndex) {
                    stepLi.classList.add('active');
                }
                stepperUl.appendChild(stepLi);
                if (index < currentSteps.length - 1) {
                    const separator = document.createElement('li');
                    separator.className = 'step-separator';
                    stepperUl.appendChild(separator);
                }
            });
            stepperWrapper.appendChild(stepperUl);
            progressTrackerContainer.style.display = 'block';
        }

        function renderStep() {
            if (!stepsContainer || currentSteps.length === 0) {
                stepsContainer.innerHTML = '<p class="placeholder-text">No steps for this scenario.</p>';
                if (nextStepBtn) nextStepBtn.style.display = 'none';
                if (prevStepBtn) prevStepBtn.style.display = 'none';
                return;
            }

            if (currentStepIndex >= 0 && currentStepIndex < currentSteps.length) {
                const stepContent = currentSteps[currentStepIndex];
                stepsContainer.innerHTML = `<p>${stepContent}</p>`; // Consider escaping HTML if steps can contain it
                animateElement(stepsContainer, 'fade-in-quick'); // Subtle animation for step change

                showAssistantMessage(`üìå Step ${currentStepIndex + 1}: ${stepContent.length > 45 ? stepContent.substring(0, 42) + "..." : stepContent}`, true, 'call', 0);

                // Timer is started/resumed here.
                // If totalElapsedSecondsOnLoad > 0, it means we're restoring, so timer will account for it.
                // If stepStartTime > 0 but totalElapsedSecondsOnLoad is 0, it means we navigated back to a step,
                // we need to decide if we reset its timer or sum up. Current stopAndRecordStepTimer replaces duration.
                // For navigating back, we might want to reset the timer for that step:
                if (totalElapsedSecondsOnLoad === 0) { // Not a page reload
                    stepStartTime = 0; // Reset timer start for this step if navigating
                }
                startStepTimer();
                saveCallState();
            } else {
                stepsContainer.innerHTML = '<p class="placeholder-text" style="color: var(--danger-color);">Error: Invalid step.</p>';
            }

            renderProgressTracker();
            if (prevStepBtn) prevStepBtn.style.display = currentStepIndex > 0 ? 'inline-flex' : 'none';
            if (nextStepBtn) {
                nextStepBtn.style.display = 'inline-flex';
                if (currentStepIndex < currentSteps.length - 1) {
                    nextStepBtn.innerHTML = `<span>Next Step</span><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>`;
                } else {
                    nextStepBtn.innerHTML = `<span>Finish Scenario</span>`;
                }
            }
        }

        // --- "Receive Call" Button ---
        if (receiveCallBtn) {
            receiveCallBtn.addEventListener('click', async () => {
                const selectedScenarioId = scenarioDropdown.value;
                if (!selectedScenarioId) {
                    showAssistantMessage("‚ö†Ô∏è Please select a scenario first.", true, 'initial', 5000);
                    return;
                }

                if (callStartSound) callStartSound.play().catch(e => console.warn("Audio play failed:", e));

                resetCallUIDandState(); // Reset state for a new call
                currentScenarioId = parseInt(selectedScenarioId, 10);

                updateSystemStatus("üü° Loading Scenario...", "status-loading");
                if (initialViewDiv) initialViewDiv.style.display = 'none';
                if (callFlowViewDiv) callFlowViewDiv.style.display = 'block'; animateElement(callFlowViewDiv);
                if (endCallBtn) endCallBtn.style.display = 'inline-flex';
                if (stepsContainer) stepsContainer.innerHTML = '<p class="placeholder-text">Loading scenario...</p>';
                if (scenarioTitleElement) scenarioTitleElement.textContent = 'Loading Scenario...';


                try {
                    const { data: { user } } = await supabase.auth.getUser(); // Session should exist due to initial check
                    if (!user) throw new Error("User not found, cannot start call.");

                    let agentName = user.user_metadata?.full_name || user.user_metadata?.name || user.email?.split('@')[0] || `Agent_${user.id.substring(0,6)}`;
                    let agentEmail = user.email || '';

                    const { data: scenarioData, error: scenarioError } = await supabase
                        .from('call_scenarios')
                        .select('title, steps')
                        .eq('id', currentScenarioId)
                        .eq('is_active', true)
                        .single();

                    if (scenarioError) throw scenarioError;
                    if (!scenarioData || !scenarioData.steps || scenarioData.steps.length === 0) {
                        throw new Error("Selected scenario is invalid or has no steps.");
                    }

                    currentScenarioName = scenarioData.title;
                    currentSteps = scenarioData.steps;
                    stepDurations = new Array(currentSteps.length).fill(0); // Initialize durations

                    const { data: newSession, error: sessionInsertError } = await supabase
                        .from('call_sessions')
                        .insert({
                            user_id: user.id,
                            scenario_id: currentScenarioId,
                            start_time: new Date().toISOString(),
                            completed: false, // Initially not completed
                            agent_name: agentName,
                            agent_email: agentEmail
                            // duration, call_quality, quality_reason, end_time will be updated on call end/finish
                        })
                        .select('id')
                        .single();

                    if (sessionInsertError) throw sessionInsertError;
                    if (!newSession || !newSession.id) throw new Error("Failed to create call session record.");

                    currentCallSessionId = newSession.id;
                    console.log("‚úÖ New call session created. ID:", currentCallSessionId);

                    if (scenarioTitleElement) scenarioTitleElement.textContent = currentScenarioName;
                    updateSystemStatus("üü¢ In Call", "status-in-call");
                    currentStepIndex = 0; // Start from the first step
                    stepStartTime = 0; // Reset for the first step's timer
                    totalElapsedSecondsOnLoad = 0;
                    renderStep(); // Render the first step
                    showAssistantMessage(`üöÄ Scenario "${currentScenarioName}" started!`, true, 'call', 0);

                } catch (err) {
                    console.error("Error during call setup:", err);
                    resetCallUIDandState();
                    updateSystemStatus("üî¥ Error", "status-error");
                    if (stepsContainer) stepsContainer.innerHTML = `<p class="placeholder-text" style="color:var(--danger-color);">Error: ${err.message}</p>`;
                    showAssistantMessage(`‚ö†Ô∏è Error starting call: ${err.message}`, true, 'initial', 7000);
                    // Show initial view again
                    if (callFlowViewDiv) callFlowViewDiv.style.display = 'none';
                    if (initialViewDiv) initialViewDiv.style.display = 'block'; animateElement(initialViewDiv);
                    if (endCallBtn) endCallBtn.style.display = 'none';
                    await loadActiveScenarios(); // Reload scenarios in case of error
                }
            });
        }

        // --- Call Navigation & End Logic ---
        async function handleCallCompletion(isFinishedSuccessfully) {
            stopAndRecordStepTimer(); // Record time for the last active step
            const totalDuration = stepDurations.reduce((acc, duration) => acc + (duration || 0), 0);

            let callQuality, qualityReason;
            if (isFinishedSuccessfully) {
                callQuality = 'Good';
                qualityReason = 'All steps completed.';
                updateSystemStatus("‚úÖ Call Completed", "status-completed");
            } else {
                callQuality = 'Bad';
                qualityReason = 'Call ended prematurely by user.';
                updateSystemStatus("‚ö™ Call Ended", "status-ended");
            }
            console.log(`Call outcome: ${qualityReason}, Total Duration: ${totalDuration}s`);

            clearCallState(); // Clear sessionStorage state *before* async DB update

            if (currentCallSessionId) {
                const updatePayload = {
                    end_time: new Date().toISOString(),
                    duration: totalDuration,
                    call_quality: callQuality,
                    quality_reason: qualityReason,
                    completed: isFinishedSuccessfully
                };
                console.log(`üöÄ Updating call_sessions (ID: ${currentCallSessionId}) with payload:`, updatePayload);
                try {
                    const { data: updateData, error: updateError } = await supabase
                        .from('call_sessions')
                        .update(updatePayload)
                        .eq('id', currentCallSessionId)
                        .select(); // select() can be useful for debugging

                    if (updateError) {
                        console.error("‚ùå Error updating call_sessions:", updateError);
                        // Update local reason if DB fails for summary display
                        qualityReason = `DB Update Failed: ${updateError.message}. Original: ${qualityReason}`;
                        callQuality = 'N/A (Update Failed)';
                    } else {
                        console.log("‚úÖ call_sessions updated successfully. Response:", updateData);
                    }
                } catch (dbErr) {
                    console.error("‚ùå Exception during call_sessions update:", dbErr);
                    qualityReason = `Exception during DB Update: ${dbErr.message}. Original: ${qualityReason}`;
                    callQuality = 'N/A (Update Exception)';
                }
            } else {
                console.error("‚ùå Cannot update session, currentCallSessionId is missing!");
                qualityReason = "Internal Error: Missing Session ID for final update.";
                callQuality = 'N/A (No Session ID)';
            }

            displayPostCallSummary(callQuality, qualityReason, totalDuration);

            // Hide call flow controls
            if (nextStepBtn) nextStepBtn.style.display = 'none';
            if (prevStepBtn) prevStepBtn.style.display = 'none';
            if (endCallBtn) endCallBtn.style.display = 'none';
            if (callTimerDiv) callTimerDiv.style.display = 'none';
            if (progressTrackerContainer) progressTrackerContainer.style.display = 'none';
        }

        if (nextStepBtn) {
            nextStepBtn.addEventListener('click', async () => {
                stopAndRecordStepTimer(); // Record duration for current step
                if (currentStepIndex < currentSteps.length - 1) {
                    currentStepIndex++;
                    stepStartTime = 0; // Reset timer for the new step
                    totalElapsedSecondsOnLoad = 0;
                    renderStep();
                } else {
                    // Last step completed - scenario finished
                    await handleCallCompletion(true);
                }
            });
        }

        if (prevStepBtn) {
            prevStepBtn.addEventListener('click', () => {
                stopAndRecordStepTimer(); // Record duration for current step
                if (currentStepIndex > 0) {
                    currentStepIndex--;
                    stepStartTime = 0; // Reset timer for the previous step
                    totalElapsedSecondsOnLoad = 0;
                    renderStep();
                }
            });
        }

        if (endCallBtn) {
            endCallBtn.addEventListener('click', async () => {
                await handleCallCompletion(false); // Call ended prematurely
            });
        }

        // --- Post Call Summary & Return to Initial View ---
        function displayPostCallSummary(quality, reason, totalDuration) {
            if (callFlowViewDiv) callFlowViewDiv.style.display = 'none';
            if (assistantBox) {
                assistantBox.classList.remove('show', 'assistant-initial-position', 'slide-in-right');
                assistantBox.style.display = 'none';
            }

            if (callSummaryContentDiv && postCallSummaryDiv) {
                let summaryHTML = `
                    <p><strong>Call Quality:</strong> <span class="quality-text quality-${quality?.toLowerCase().replace(/\s+/g, '-') || 'na'}">${quality || 'N/A'}</span></p>
                    <p><strong>Reason:</strong> ${reason || "N/A"}</p>
                    <p><strong>Total Duration:</strong> ${Math.floor(totalDuration / 60)}m ${totalDuration % 60}s</p>
                    <hr style="margin: 1rem 0; border-color: var(--border-color);">
                    <p><strong>Step Durations:</strong></p>
                    <ul style="list-style: none; padding-left: 0; max-height: 150px; overflow-y: auto;">`;

                if (currentSteps && currentSteps.length > 0 && stepDurations && stepDurations.length > 0) {
                    const maxValidIndex = Math.min(currentSteps.length, stepDurations.length);
                    for (let i = 0; i < maxValidIndex; i++) {
                        const duration = stepDurations[i] || 0;
                        const stepText = currentSteps[i] || `Step ${i + 1}`;
                        const stepShortText = stepText.length > 30 ? stepText.substring(0, 27) + "..." : stepText;
                        const timeStr = `${Math.floor(duration / 60)}m ${duration % 60}s`;
                        // Determine status based on whether the step's duration is > 0
                        const stepStatus = duration > 0 ? "Visited" : "Not Reached";
                        if (i === currentStepIndex && quality !== 'Good' && duration > 0) { // If call ended at this step
                             summaryHTML += `<li style="margin-bottom: 0.3rem;">${i + 1}. "${stepShortText}" (Ended At): ${timeStr}</li>`;
                        } else if (duration > 0) {
                             summaryHTML += `<li style="margin-bottom: 0.3rem;">${i + 1}. "${stepShortText}" (Completed): ${timeStr}</li>`;
                        } else {
                             summaryHTML += `<li style="margin-bottom: 0.3rem; opacity: 0.6;">${i + 1}. "${stepShortText}" (Not Reached)</li>`;
                        }
                    }
                } else {
                    summaryHTML += `<li>No step duration data available.</li>`;
                }
                summaryHTML += `</ul>`;

                callSummaryContentDiv.innerHTML = summaryHTML;
                postCallSummaryDiv.style.display = 'block';
                animateElement(postCallSummaryDiv);
            }
            updateSystemStatus("üìä Review Call Summary", "status-summary");
        }

        if (returnToInitialViewBtn) {
            returnToInitialViewBtn.addEventListener('click', async () => {
                resetCallUIDandState(); // Full reset

                if (postCallSummaryDiv) postCallSummaryDiv.style.display = 'none';
                if (callFlowViewDiv) callFlowViewDiv.style.display = 'none';
                if (initialViewDiv) {
                    initialViewDiv.style.display = 'block';
                    animateElement(initialViewDiv);
                }
                updateSystemStatus("üî¥ Waiting for Call", "status-waiting");

                if (nextStepBtn) nextStepBtn.style.display = 'none';
                if (prevStepBtn) prevStepBtn.style.display = 'none';
                if (endCallBtn) endCallBtn.style.display = 'none';
                if (scenarioTitleElement) scenarioTitleElement.textContent = "Call Scenario";
                if (stepsContainer) stepsContainer.innerHTML = '<p class="placeholder-text">Select a scenario to begin.</p>';

                await loadActiveScenarios(); // Reload scenarios
                if (scenarioDropdown) scenarioDropdown.value = "";
                if (receiveCallBtn) receiveCallBtn.disabled = true;

                showAssistantMessage("üí° Ready for the next call! Select a scenario.", true, 'initial', 7000);
            });
        }


        // --- Assistant Box Logic ---
        function typeWriterEffect(element, message, speed = 30, callback) {
            if (typingInterval) clearInterval(typingInterval);
            element.textContent = '';
            let i = 0;
            typingInterval = setInterval(() => {
                if (i < message.length) {
                    element.textContent += message.charAt(i);
                    i++;
                } else {
                    clearInterval(typingInterval);
                    typingInterval = null;
                    if (callback) callback();
                }
            }, speed);
        }

        function showAssistantMessage(message, showImmediately = false, position = 'call', duration = 5000, onHideCallback) {
            if (!assistantMessageElement || !assistantBox) return;

            clearTimeout(assistantTimeout);
            if (typingInterval) clearInterval(typingInterval);

            const isCurrentlyVisible = assistantBox.style.display === 'flex' && assistantBox.classList.contains('show');
            const isInitialPosition = assistantBox.classList.contains('assistant-initial-position');

            const displayMessage = () => {
                assistantBox.style.display = 'flex';
                assistantBox.classList.remove('show', 'slide-in-right', 'assistant-initial-position');
                void assistantBox.offsetWidth; // Trigger reflow

                if (position === 'initial') {
                    assistantBox.classList.add('assistant-initial-position');
                     // For initial, we might not want slide-in, just ensure it's visible
                } else { // 'call' position
                    assistantBox.classList.add('slide-in-right', 'show');
                }
                assistantBox.classList.add('show'); // General visibility class


                typeWriterEffect(assistantMessageElement, message, 30, () => {
                    if (duration > 0) {
                        assistantTimeout = setTimeout(() => {
                            hideAssistant(position);
                            if (typeof onHideCallback === 'function') onHideCallback();
                        }, duration);
                    }
                });
            };

            const hideAssistant = (currentPosition) => {
                 if (currentPosition === 'initial') {
                    // For initial position, might just hide directly or fade out
                    // assistantBox.style.display = 'none'; // Or add a fade-out class
                    // assistantBox.classList.remove('show');
                 } else { // 'call' position
                    assistantBox.classList.remove('show'); // This should trigger slide-out via CSS
                     // Wait for transition to complete before setting display to none
                    //  setTimeout(() => {
                    //      if (!assistantBox.classList.contains('show')) { // Check if still hidden
                    //          assistantBox.style.display = 'none';
                    //      }
                    //  }, 400); // Match CSS transition duration
                 }
                 // General hide after a delay or if no specific hide animation
                 // If duration is 0, message stays until new one or explicit hide
                 if (duration > 0) {
                    setTimeout(() => {
                        if (!assistantBox.classList.contains('show')) { // if it was hidden by animation
                             assistantBox.style.display = 'none';
                        } else if (currentPosition === 'initial' && !assistantBox.classList.contains('slide-in-right')) {
                             // if it's initial and wasn't meant to slide, just hide
                             assistantBox.style.display = 'none';
                        }
                    }, 400);
                 } else if (duration === 0 && position === 'initial' && !message.startsWith("Welcome!")) {
                     // Special case: if duration is 0 for initial and it's not the welcome message, don't auto-hide
                 } else if (duration === 0 && position === 'call') {
                     // Call messages with 0 duration stay until next message
                 }

            };


            // Logic for showing/hiding
            if (showImmediately || !isCurrentlyVisible || (position === 'initial' && !isInitialPosition) || (position === 'call' && isInitialPosition)) {
                displayMessage();
            } else { // Already visible and in correct position, just update text
                typeWriterEffect(assistantMessageElement, message, 30, () => {
                    if (duration > 0) {
                        assistantTimeout = setTimeout(() => {
                            hideAssistant(position);
                            if (typeof onHideCallback === 'function') onHideCallback();
                        }, duration);
                    }
                });
            }
        }
        console.log("Elevo Core Assistant script fully loaded and initialized - v3.0");
    });
    </script>
</body>
</html>
